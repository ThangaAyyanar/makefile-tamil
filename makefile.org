#+title: Makefile Tutorial By Example
#+author: Translated by Thanga Ayyanar

நான் இந்த வழிகாட்டியை உருவாக்கினேன், ஏனென்றால் என்னால் மேக் கோப்பு (Makefile) பற்றி சுற்றிக்கொள்ள கடினமாக இருந்ததால். அவைகளில் மறைந்திருக்கும் விதிகள் மற்றும் மறைமுகமான சின்னங்களைக் கொண்டு இருக்கிறது, மேலும் எளிமையான கேள்விக்கு எளிமையான பதில்களைக் கொடுக்கவில்லை. இதைத் தீர்க்க, நான் பல வார இறுதிகளில் அமர்ந்து மேக் கோப்பு பற்றி என்னால் முடிந்த அனைத்தையும் படித்தேன். இந்த வழிகாட்டியில் மிக முக்கியமான விஷயங்களை நான் சுருக்கி தொகுத்து உள்ளேன். ஒவ்வொரு தலைப்புக்கும் ஒரு சுருக்கமான விளக்கமும், சுயமாக இயங்கக்கூடிய ஒரு உதாரணமும் உள்ளது.

நீங்கள் பெரும்பாலும் மேக் ஐப் புரிந்து கொண்டால், மேக் கோப்பு பயனர் கையேடுவைப் (cookbook) பார்க்கவும், இதில் மேக் கோப்பு இன் ஒவ்வொரு பகுதியும் என்ன செய்கிறது என்பதைப் பற்றிய போதுமான கருத்துகளைக் கொண்ட நடுத்தர அளவிலான திட்டங்களுக்கான (project) படிம அச்சு(template) உள்ளது.

நல் வாழ்த்துக்கள், மேக் கோப்புகளின் குழப்பமான உலகத்தை உங்களால் புரிந்துகொள்ள முடியும் என்று நம்புகிறேன்!

* துவக்கம் ஆரம்பிக்கிறது

** மேக் கோப்புகள் ஏன் உள்ளன?
ஒரு பெரிய நிரலின் எந்தப் பகுதிகளை மறுநிரல்மொழிமாற்ற(recompile) வேண்டும் என்பதைத் தீர்மானிக்க மேக் கோப்புகள் பயன்படுத்தப்படுகின்றன. பெரும்பாலான சந்தர்ப்பங்களில், C அல்லது C++ கோப்புகள் நிரல்மொழிமாற்ற(compile) படுகின்றன. பிற மொழிகள் பொதுவாக மேக் போன்ற அதே சேவை செய்யும் சொந்த கருவிகளைக் கொண்டுள்ளன. மேக் நிரல்மொழிமாற்ற மட்டும் இல்லாமல் எந்த கோப்புகள் மாறிவிட்டன என்பதைப் பொறுத்து இயக்குவதற்கு உங்களுக்கு தொடர்ச்சியான வழிமுறைகள்(series of instruction) தேவைப்படும்போதும் பயன்படுத்தலாம். 

இந்த பயிற்சியில் C/C++ நிரல்மொழிமாற்ற பயன்பாட்டு விஷயத்தில் கவனம் செலுத்தும்.

மேக் மூலம் நீங்கள் உருவாக்கக்கூடிய சார்பு வரைபடம் (dependency graph) இங்கே உள்ளது. ஏதேனும் கோப்பின் சார்புகள்(dependency) மாறினால், கோப்பு மீண்டும் நிரல்மொழிமாற்றபடும்:

#+CAPTION: Sample dependency graph for make file
#+NAME:   fig:make-dependency-graph

[[./assets/dependency_graph.png]]

** மேக் மாற்றாக வேறு என்ன மென்பொருள் உள்ளன?
பிரபலமான C/C++ க்கு மாற்று உருவாக்க அமைப்புகள்(Build tools) SCons, CMake, Bazel மற்றும் Ninja ஆகும். மைக்ரோசாஃப்ட் விஷுவல் ஸ்டுடியோ(Microsoft Visual Studio) போன்ற சில குறியீடு தொகுப்பிகள்(code editors) தங்களுக்கென உள்ளமைக்கப்பட்ட கருவிகளைக் (inbuilt tools) கொண்டுள்ளனர். ஜாவாவிற்கு(Java), அன்ட் (Ant), மேவன்(Maven) மற்றும் கிரேடில்(Gradle) உள்ளன. கோ(Go), ரஸ்ட்(Rust) மற்றும் டைப்ஸ்கிரிப்ட்(Typescript) போன்ற பிற மொழிகள் அவற்றின் சொந்த உருவாக்கப்பட்ட கருவிகளைக் கொண்டுள்ளன.

பைதான்(Python), ரூபி(Ruby) மற்றும் ரா ஜாவாஸ்கிரிப்ட்(Raw Javascript) போன்ற நிரற்பெயர்ப்பி மொழிகளுக்கு (Interpreted language) மேக் கோப்பு தேவையில்லை. மேக் கோப்புபின் குறிக்கோள், எந்த கோப்புகள் மாறியுள்ளன என்பதை அடிப்படையாகக் கொண்டு நிரல்மொழிமாற்ற வேண்டிய கோப்புகளை நிரல்மொழிமாற்ற வேண்டும். ஆனால் நிரற்பெயர்ப்பி மொழிகளில் உள்ள கோப்புகள் மாறும்போது, ​​எதையும் மறுநிரல்மொழிமாற்ற வேண்டியதில்லை. நிரல் இயங்கும் போது, ​​கோப்பின் சமீபத்திய பதிப்புயை பயன்படுத்தப்படும்.

** மேக்கின் பதிப்புகள் மற்றும் வகைகள்
மேக்கின் பல்வேறு செயலாக்கங்கள்(implementation) உள்ளன, ஆனால் இந்த வழிகாட்டியில் பெரும்பாலானவை நீங்கள் பயன்படுத்தும் எந்தப் பதிப்பிலும்(version) வேலை செய்யும். இருப்பினும், இது குறிப்பாக குனு மேக்காக(GNU Make) எழுதப்பட்டது, இது லினக்ஸ் மற்றும் மாக்(Mac) இல் நிலையான செயலாக்கமாகும். அனைத்து எடுத்துக்காட்டுகளும் மேக் பதிப்புகள் 3 மற்றும் 4 க்கு வேலை செய்கின்றன, அவை சில மறைபொருள்(esoteric) வேறுபாடுகளைத் தவிர கிட்டத்தட்ட சமமானவை.

** எடுத்துக்காட்டுகளை இயக்குதல்
இந்த உதாரணங்களை இயக்க, உங்களுக்கு கட்டளை வரி(Terminal/Command Line) மற்றும் "மேக்" நிறுவயிருக்க வேண்டும். ஒவ்வொரு உதாரணத்திற்கும், ~Makefile~ எனப்படும் கோப்பில் உள்ளடக்கங்களை(contents) வைத்து, அந்த கோப்பகத்தில்(folder) மேக் கட்டளையை இயக்கவும். எளிமையான மேக் கோப்பு உடன் ஆரம்பிக்கலாம்:

#+begin_src makefile
hello:
	echo "Hello, World"
#+end_src

*குறிப்பு*: மேக் கோப்பு TABகளைப் பயன்படுத்தி உள்தள்ளப்பட(indent) வேண்டும், இடைவெளிகள்(space) பயன்படுத்தினால் make தோல்வியடையும்.

மேலே உள்ள உதாரணத்தை இயக்குவதன் வெளியீடு(output) இங்கே:
#+begin_src shell
$ make
echo "Hello, World"
Hello, World
#+end_src

அவ்வளவுதான்!

** மேக் கோப்பு தொடரியல்(Syntax)
ஒரு மேக் கோப்பு விதிகளின் தொகுப்பைக்(set of rules) கொண்டுள்ளது. ஒரு விதி பொதுவாக இது போல் இருக்கும்:
#+begin_src makefile
இலக்குகள்: முன்நிபந்தனைகள்
	கட்டளை
	கட்டளை
	கட்டளை	  
#+end_src
- இலக்குகள் கோப்பு பெயர்கள், இடைவெளிகளால்(space) பிரிக்கப்படுகின்றன. பொதுவாக, ஒரு விதிக்கு ஒன்று மட்டுமே இருக்க வேண்டும்.
- கட்டளைகள் என்பது இலக்கை (களை) உருவாக்க பொதுவாகப் பயன்படுத்தப்படும் படிகளின் வரிசையாகும்(series of steps). இவை Tab எழுத்துடன் தொடங்க வேண்டும், இடைவெளிகள்(space) அல்ல.
- முன்நிபந்தனைகள் கோப்பு பெயர்கள், இடைவெளிகளால் பிரிக்கப்படுகின்றன. இலக்குக்கான கட்டளைகளை இயக்கும் முன் இந்தக் கோப்புகள் இருக்க வேண்டும். இவை சார்புகள்(dependency) என்றும் அழைக்கப்படுகின்றன.

** மேக்கின் சாராம்சம்
ஒரு உலகத்திற்கு வணக்கம்(Hello world) உதாரணத்துடன் ஆரம்பிக்கலாம்:
#+begin_src makefile
hello:
	echo "Hello, World"
	echo "This line will print if the file hello does not exist."	  
#+end_src

ஏற்கனவே இங்கே கற்றுக்கொள்ள நிறைய இருக்கிறது. அதை ஒவ்வொன்றாக பார்க்கவும்:
- நம்மிடம் ~hello~ என்று ஒரு இலக்கு உள்ளது
- இந்த இலக்கு இரண்டு கட்டளைகளைக் கொண்டுள்ளது
- இந்த இலக்குக்கு முன்நிபந்தனைகள் எதுவும் இல்லை

நாம் ~make hello~ என்று இயக்குவோம். hello கோப்பு இல்லாத வரை, கட்டளைகள் இயங்கும். hello இருந்தால், எந்த கட்டளையும் இயங்காது.

நான் hello ஒரு இலக்கு மற்றும் ஒரு கோப்பு என்று பேசுகிறேன் என்பதை உணர வேண்டியது அவசியம். இரண்டும் நேரடியாக இணைந்திருப்பதே இதற்குக் காரணம். பொதுவாக, ஒரு இலக்கு இயக்கப்படும் போது (ஒரு இலக்கின் கட்டளைகள் இயக்கப்படும் போது), கட்டளைகள் இலக்கின் அதே பெயரில் ஒரு கோப்பை உருவாக்கும். இந்த வழக்கில், hello இலக்கு hello கோப்பை உருவாக்காது.

மிகவும் பொதுவான மேக் கோப்புகலை உருவாக்குவோம் - ஒரு சி கோப்பை நிரல்மொழிமாற்றும்(compile). ஆனால் நாம் அதை செய்வதற்கு முன், பின்வரும் உள்ளடக்கங்களைக் கொண்ட blah.c என்ற கோப்பை உருவாக்கவும்:
#+NAME: blah.c
#+begin_src c
// blah.c
#include<stdio.h>
int main() { 
  return 0; 
}
#+end_src
பின்னர் Makefile எனப்படும் கோப்புயை உருவாக்கவும். அதில் பின்வரும் உள்ளடக்கங்களை எழுதவும்.
#+begin_src makefile
blah:
	cc blah.c -o blah	  
#+end_src

இந்த நேரத்தில், make ஐ இயக்க முயற்சிக்கவும். மேக் கட்டளைக்கு தருமதிப்பு(argument) என எந்த இலக்கும் வழங்கப்படவில்லை என்பதால், முதல் இலக்கு இயக்கப்படுகிறது. இந்த வழக்கில், ஒரே ஒரு இலக்கு (blah) உள்ளது. நீங்கள் இதை முதல் முறையாக இயக்கும் போது, ​​blah உருவாக்கப்படும். இரண்டாவது முறை, நீங்கள் make இயக்கும் போது ~make: 'blah' is up to date~ என்று வரும். ஏனென்றால் blah கோப்பு ஏற்கனவே இருப்பதால் தான். ஆனால் ஒரு சிக்கல் உள்ளது: நாம் blah.c ஐ மாற்றியமைத்த, பின்னர் make ஐ இயக்கினால், எதுவும்  மறுநிரல்மொழிமாற்ற(recompile) படாது.

ஒரு முன்நிபந்தனையைச் சேர்ப்பதன் மூலம் இதை நாம் தீர்க்கிறோம்:
#+begin_src makefile
blah: blah.c
	cc blah.c -o blah	  
#+end_src
மீண்டும் make ஐ இயக்கும்போது, ​​பின்வரும் படிநிலைகள் நடக்கும்:

- முதல் இலக்கு தேர்ந்தெடுக்கப்பட்டது, ஏனெனில் முதல் இலக்கு இயல்புநிலை(default) இலக்காகும்
- இதற்கு blah.c இன் முன்நிபந்தனை உள்ளது
- அது blah இலக்கை இயக்க வேண்டுமா என்பதை முடிவு செய்யும். blah இல்லாவிட்டால் அல்லது blah.c, blah விட புதியதாக இருந்தால் மட்டுமே அது இயங்கும்

இந்த கடைசி படி முக்கியமானதாகும், மேலும் இது make இன் சாராம்சமாகும். அது என்ன செய்ய முயற்சிக்கிறது என்றால் blah கடைசியாக நிரல்மொழிமாற்ற பட்டதிலிருந்து blah முன்நிபந்தனைகள் மாறியிருக்கிறதா என்று. அதாவது, blah.c மாற்றியமைக்கப்பட்டால், மேக் கோப்பை மறுநிரல்மொழிமாற்ற(recompile) வேண்டும். மற்றும் மாறாக, blah.c மாறவில்லை என்றால், அது மறுநிரல்மொழிமாற்ற(recompile) கூடாது.

இதைச் செய்ய, கோப்பமைப்பு நேர முத்திரைகளை(Timestamp) பதிலியாக(proxy) பயன்படுத்தி ஏதாவது மாற்றம் ஏற்பட்டுள்ளதா என்பதைத் தீர்மானிக்கிறது. இது ஒரு நியாயமான பட்டறிவுசார்(heuristic) ஆகும், ஏனெனில் கோப்பு நேர முத்திரைகள் பொதுவாக கோப்புகள் மாற்றப்பட்டால் மட்டுமே மாறும். ஆனால் இது எப்போதும் இப்படி இருக்காது என்பதை உணர வேண்டியது அவசியம். உதாரணமாக, நீங்கள் ஒரு கோப்பை மாற்றலாம், பின்னர் அந்தக் கோப்பின் மாற்றியமைக்கப்பட்ட நேர முத்திரையை பழையதாக மாற்றலாம். நீங்கள் அவ்வாறு செய்தால், கோப்பு மாறவில்லை என்று மேக் தவறாக யூகித்து, இயக்கத்தை புறக்கணிக்கப்படலாம்.

இதை நீங்கள் புரிந்துகொள்வதை உறுதிப்படுத்திக் கொள்ளுங்கள். இது Makefiles இன் முக்கிய அம்சமாகும், மேலும் நீங்கள் சரியாகப் புரிந்துகொள்ள சில நிமிடங்கள் ஆகலாம். மேலே உள்ள உதாரணங்களுடன் விளையாடுங்கள்.

** மேலும் விரைவான எடுத்துக்காட்டுகள்

பின்வரும் மேக் கோப்பு இறுதியில் மூன்று இலக்குகளையும் இயக்குகிறது. நீங்கள் கட்டளை வரியில்(Terminal/Command Line) make ஐ இயக்கும் போது, ​​அது தொடர்ச்சியான படிகளில் blah எனப்படும் நிரலை உருவாக்கும்:

- இலக்கு blah ஐ Make தேர்வு செய்கிறது, ஏனெனில் முதல் இலக்கு இயல்புநிலை(default) இலக்காகும்
- blah க்கு blah.o தேவைப்படுகிறது, எனவே blah.o இலக்கைத் தேடுகிறது
- blah.o க்கு blah.c தேவைப்படுகிறது, எனவே blah.c இலக்கைத் தேடுகிறது
- blah.c க்கு சார்புகள்(dependency) இல்லை, எனவே echo கட்டளை இயக்கப்படுகிறது
- cc -c கட்டளை இயக்கப்படுகிறது, ஏனெனில் blah.o சார்புகள் அனைத்தும் முடிந்துவிட்டன
- மேல் cc கட்டளை இயக்கப்படுகிறது, ஏனெனில் அனைத்து blah சார்புகளும் முடிந்துவிட்டன
- அவ்வளவுதான்: blah ஒரு நிரல்மொழிமாற்ற பட்ட c நிரல்
#+begin_src makefile
blah: blah.o
	cc blah.o -o blah # முன்றாவது ஆக இயங்கும்

blah.o: blah.c
	cc -c blah.c -o blah.o # இரண்டாவது ஆக இயங்கும்

# பொதுவாக blah.c ஏற்கனவே இருக்கும், ஆனால் தேவையான கூடுதல் கோப்புகளை நான் குறைக்க விரும்புகிறேன்
blah.c:
	echo "int main() { return 0; }" > blah.c # முதலில் இயங்கும்	  
#+end_src

நீங்கள் blah.c ஐ நீக்கினால், மூன்று இலக்குகளும் மீண்டும் இயக்கப்படும். நீங்கள் அதைத் திருத்தினால் (இதனால் நேர முத்திரையை blah.o ஐ விட புதியதாக மாறும்), முதல் இரண்டு இலக்குகள் இயங்கும். நீங்கள் touch blah.o ஐ இயக்கினால் (இதனால் நேர முத்திரையை blah ஐ விட புதியதாக மாறும்), பிறகு முதல் இலக்கு மட்டுமே இயங்கும். நீங்கள் எதையும் மாற்றவில்லை என்றால், இலக்குகள் எதுவும் இயங்காது. முயற்சி செய்து பாருங்கள்!

இந்த அடுத்த உதாரணம் புதிதாக எதையும் செய்யவில்லை, இருப்பினும் இது ஒரு நல்ல கூடுதல் எடுத்துக்காட்டு. இது எப்போதும் இரண்டு இலக்குகளையும் இயக்கும், ஏனெனில் some_file other_file சார்ந்தது, அது எப்போதும் கோப்பை உருவாக்காது.
#+begin_src makefile
some_file: other_file
	echo "This will always run, and runs second"
	touch some_file

other_file:
	echo "This will always run, and runs first"	  
#+end_src

** மேக் கிளீன் (make clean)

clean என்பது பெரும்பாலும் மற்ற இலக்குகளின் வெளியீட்டை(output) அகற்றும் இலக்காகப் பயன்படுத்தப்படுகிறது, ஆனால் இது மேக் என்பதில் ஒரு சிறப்புச் சொல் அல்ல. some_file உருவாக்க மற்றும் நீக்க, இதில் make மற்றும் make clean இயக்கலாம்.

கிளீன்(clean) இங்கே இரண்டு புதிய விஷயங்களைச் செய்கிறது என்பதை நினைவில் கொள்க:

- இது முதலில் இல்லாத ஒரு இலக்கு (இயல்புநிலை), மற்றும் இதற்கு முன்நிபந்தனை அல்ல. அதாவது make clean என்று நீங்கள் வெளிப்படையாக அழைக்கும் வரை இது இயங்காது
- இது ஒரு கோப்பு பெயராக இருக்கவில்லை. உங்களிடம் ஒரு கோப்பு clean என்று இருந்தால், இந்த இலக்கு இயங்காது, அது நாம் விரும்புவதில்லை. இதை எப்படி சரிசெய்வது என்பது குறித்த இந்த பயற்சியில் .PHONYஐப் என்று பிறகு பார்ப்போம்.

#+begin_src makefile
some_file: 
	touch some_file

clean:
	rm -f some_file	  
#+end_src

** மாறிகள்(variables)
மாறிகள் சரங்களாக(string) மட்டுமே இருக்க முடியும். நீங்கள் பொதுவாக := ஐப் பயன்படுத்துவோம், ஆனால் = ஏன் வேலை செய்கிறது. மாறிகள் பாகம் 2 ஐப் பார்க்கவும்.

மாறிகளைப் பயன்படுத்துவதற்கான எடுத்துக்காட்டு இங்கே:
#+begin_src makefile
files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file	  
#+end_src
ஒற்றை அல்லது இரட்டை மேற்கோள்களுக்கு(quotes) அர்த்தம் இல்லை மேக்கில். அவை வெறுமனே மாறிக்கு ஒதுக்கப்பட்ட எழுத்துக்கள். மேற்கோள்கள் ஷெல்(shell)/பாஷுக்கு(Bash) பயனுள்ளதாக இருக்கும், மேலும் அவை உங்களுக்கு printf போன்ற கட்டளைகளில் தேவைப்படும். இந்த எடுத்துக்காட்டில், இரண்டு கட்டளைகளும் ஒரே மாதிரியாக செயல்படுகின்றன:
#+begin_src makefile
a := one two # a ஆனது "one two" என்ற சரத்திற்கு அமைக்கப்பட்டுள்ளது
b := 'one two' # பரிந்துரைக்கப்படவில்லை. b ஆனது "'one two'" சரத்திற்கு அமைக்கப்பட்டுள்ளது
all:
	printf '$a'
	printf $b
#+end_src
மாறிகளைப் பயன்படுத்த ${} அல்லது $()
#+begin_src makefile
x := dude

all:
	echo $(x)
	echo ${x}

	echo $x # தவறான நடைமுறை, ஆனால் வேலை செய்கிறது
#+end_src

* இலக்குகள் (Targets)
** all இலக்கு
பல இலக்குகளை உருவாக்கி, அவை அனைத்தும் இயங்க வேண்டுமா? all இலக்கை உருவாக்குங்கள். இது பட்டியலிடப்பட்ட முதல் விதி என்பதால், இலக்கைக் குறிப்பிடாமல் make என்று அழைக்கப்பட்டால் அது இயல்பாகவே இயங்கும்.
#+begin_src makefile
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
#+end_src

** பல இலக்குகள் (Multiple targets)
ஒரு விதிக்கு பல இலக்குகள் இருக்கும்போது, ​​ஒவ்வொரு இலக்கிற்கும் கட்டளைகள் இயக்கப்படும். $@ என்பது இலக்கு பெயரைக் கொண்ட ஒரு தானியங்கி மாறி(automatic variable).
#+begin_src makefile
all: f1.o f2.o

f1.o f2.o:
	echo $@
# இதற்கு சமம்:
# f1.o:
#	 echo f1.o
# f2.o:
#	 echo f2.o
#+end_src

* தானியங்கி மாறிகள் மற்றும் குழுக்குறிகள் (Automatic variables and wildcards)
** * குழுக்குறி

மேக்கில் * மற்றும் % ஆகிய இரண்டும் குழுக்குறிகள் என்று அழைக்கப்படுகின்றன, ஆனால் அவை முற்றிலும் வேறுபட்ட விஷயங்களைக் குறிக்கின்றன. * பொருந்தக்கூடிய கோப்புப் பெயர்களுக்கு உங்கள் கோப்பமைப்புத்(file system) தேடுகிறது. நீங்கள் எப்போதும் குழுக்குறி செயல்பாட்டில்(function) குழுக்குறியை மடிக்குமாறு(wrap) நான் பரிந்துரைக்கிறேன், இல்லையெனில் கீழே விவரிக்கப்பட்டுள்ள பொதுவான சிக்கலில் நீங்கள் விழலாம்.

#+begin_src makefile
# ஒவ்வொரு .c கோப்பு பற்றிய கோப்பு தகவலை அச்சிடவும்
print: $(wildcard *.c)
	ls -la  $?
#+end_src

\* இலக்கு, முன்நிபந்தனைகள் அல்லது குழுக்குறி செயல்பாட்டில் பயன்படுத்தப்படலாம்.

ஆபத்து: * மாறி வரையறைகளில் நேரடியாகப் பயன்படுத்தப்படாமல் இருக்கவும்
ஆபத்து: * கோப்புகளுடன் பொருந்தவில்லை என்றால், அது அப்படியே விடப்படும் (வைல்டு கார்டு செயல்பாட்டில் இயங்காத வரை)

#+begin_src makefile
thing_wrong := *.o #இதை செய்யாதே! '*' விரிவாக்கப்படாது
thing_right := $(wildcard *.o)

all: one two three four

# தோல்வி, ஏனெனில் $(thing_wrong) என்பது சரம் "*.o"
one: $(thing_wrong)


# இந்த வடிவத்துடன் பொருந்தக்கூடிய கோப்புகள் இல்லை என்றால் *.o ஆக இருக்கும் :(
two: *.o 

# நீங்கள் எதிர்பார்ப்பது போல் வேலை செய்கிறது! இந்த நிலையில், அது எதுவும் செய்யாது.
three: $(thing_right)

# விதி மூன்று போலவே
four: $(wildcard *.o)	  
#+end_src

** % குழுக்குறி
% உண்மையில் பயனுள்ளது, ஆனால் இது பல்வேறு சூழ்நிலைகளில் பயன்படுத்தப்படுவதால் சற்றே குழப்பமாக இருக்கும்.

- "பொருந்தும்"(macthing) பயன்முறையில் பயன்படுத்தப்படும் போது, ​​அது ஒரு சரத்தில் ஒன்று அல்லது அதற்கு மேற்பட்ட எழுத்துகளுடன் பொருந்தும். இந்த பொருத்தம் தண்டு(stem) என்று அழைக்கப்படுகிறது.
- "மாற்று"(replacing) பயன்முறையில் பயன்படுத்தப்படும் போது, ​​அது பொருந்திய தண்டை எடுத்து ஒரு சரத்தில் மாற்றுகிறது.
- % பெரும்பாலும் விதி வரையறைகளிலும்(rule definitions) சில குறிப்பிட்ட செயல்பாடுகளிலும் பயன்படுத்தப்படுகிறது.

இது பயன்படுத்தப்பட்டதற்கான எடுத்துக்காட்டுகளில் இந்த பிரிவுகளைப் பார்க்கவும்:

- நிலையான வடிவ விதிகள் (Static Pattern Matching)
- வடிவ விதிகள் (Pattern matching)
- சரம் மாற்று (String Subtitution)
- vpath உத்தரவு (The vpath directive)

** தானியங்கி மாறிகள் (Automatic variable)
பல தானியங்கி மாறிகள் உள்ளன, ஆனால் பெரும்பாலும் சில மட்டுமே காண்பிக்கப்படுகின்றன:
#+begin_src makefile
hey: one two
	# இது இலக்கு பெயர் என்பதால், "hey" வெளியீடுகள்
	echo $@

	# இலக்கை விட புதியதாக இருக்கும் அனைத்து முன்நிபந்தனைகளையும் வெளியிடுகிறது
	echo $?

	# அனைத்து முன்நிபந்தனைகளையும் வெளியிடுகிறது
	echo $^

	# முதல் முன்நிபந்தனையை வெளியிடுகிறது
	echo $<

	touch hey

one:
	touch one

two:
	touch two

clean:
	rm -f hey one two
#+end_src

* ஆடம்பரமான விதிகள்
** மறைமுக விதிகள் (implicit rules)

மேக் க்கு சி நிரல்மொழி மாற்றுதல் மிகவும் பிடிக்கும். ஒவ்வொரு முறையும் அது தன் அன்பை வெளிப்படுத்தும் போது, ​​விஷயங்கள் குழப்பமடைகின்றன. ஒருவேளை மேக்கின் மிகவும் குழப்பமான பகுதி மேஜிக்/தானியங்கி விதிகள்(Automatic rules) ஆகும். இந்த "மறைமுகமான" விதிகளை என்றும் அழைக்கபடுகின்றன. இந்த வடிவமைப்பு முடிவை(design decision) நான் தனிப்பட்ட முறையில் ஏற்கவில்லை, மேலும் அவற்றைப் பயன்படுத்த நான் பரிந்துரைக்கவில்லை, ஆனால் அவை அடிக்கடி பயன்படுத்தப்படுகின்றன, எனவே தெரிந்துகொள்வது பயனுள்ளதாக இருக்கும். மறைமுக விதிகளின் பட்டியல் இங்கே:

- ஒரு C நிரலைத் நிரல்மொழிமாற்றுதல்: ~$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@~ என்ற படிவத்தின் கட்டளையுடன் n.c இலிருந்து n.o தானாகவே உருவாக்கப்படுகிறது.
- C++ நிரலைத் நிரல்மொழிமாற்றுதல்: ~$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@~ என்ற படிவத்தின் கட்டளையுடன் n.cc அல்லது n.cpp இலிருந்து n.o தானாகவே உருவாக்கப்படுகிறது.
- ஒற்றை பொருள்(object) கோப்பை இணைக்க(linking): ~$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@~ கட்டளையை இயக்குவதன் மூலம் n.o இலிருந்து n தானாகவே உருவாக்கப்படுகிறது.

மறைமுக விதிகளால் பயன்படுத்தப்படும் முக்கியமான மாறிகள்:

 CC: C நிரல்களை நிரல்மொழிமாற்று வதற்கான நிரல்; இயல்புநிலை(default) cc
 CXX: C++ நிரல்களைத் நிரல்மொழிமாற்று வதற்கான நிரல்; இயல்புநிலை(default) g++
 CFLAGS: C கம்பைலருக்கு கொடுக்க கூடுதல் கொடிகள்
 CXXFLAGS: C++ நிரல்மொழிமாற்றிக்கு கொடுக்க கூடுதல் கொடிகள்
 CPPFLAGS: C நிரல்மொழிமாற்றிக்கு கொடுக்க கூடுதல் கொடிகள்
 LDFLAGS: நிரல்மொழிமாற்றிகள் இணைப்பாளரைத்(Linker) தூண்டும் போது கொடுக்க வேண்டிய கூடுதல் கொடிகள்

இப்போது நாம் எப்படி C நிரலை உருவாக்குவது என்று பார்ப்போம், நிரல்மொழிமாற்றிதல் எப்படி செய்வது என்று வெளிப்படையாகச் சொல்லாமல்:
#+begin_src makefile
CC = gcc # மறைமுக விதிகளுக்கான கொடி
CFLAGS = -g # மறைமுக விதிகளுக்கான கொடி. பிழைத்திருத்தத் தகவலை இயக்கவும்

# மறைமுக விதி #1: சி இணைப்பான் மறைமுக விதி வழியாக blah உருவக்கப்பட்டது
# மறைமுக விதி #2: blah.o ஆனது C நிரல்மொழிமாற்றியின் மறைமுக விதியின் மூலம் உருவக்கப்பட்டது, ஏனெனில் blah.c ஏற்கனவே இருக்கிறது
blah: blah.o

blah.c:
	echo "int main() { return 0; }" > blah.c

clean:
	rm -f blah*
#+end_src

** நிலையான வடிவ விதிகள் (Static Pattern Rules)

நிலையான வடிவ விதிகள் மேக் கோப்பு குறைவாக எழுத மற்றொரு வழி. இதோ அவைகளின் தொடரியல்(syntax):
#+begin_src makefile
இலக்குகள்...: இலக்கு-வடிவம்: முன்நிபந்தனை-வடிவங்கள் ...
 கட்டளைகள்
#+end_src

சாராம்சம் என்னவென்றால், கொடுக்கப்பட்ட இலக்கு இலக்கு-வடிவத்துடன் (% குழுக்குறி வழியாக) பொருந்துகிறது. எது பொருந்தியதோ அது தண்டு(stem) எனப்படும். இலக்கின் முன்நிபந்தனைகளை உருவாக்க, தண்டு முன்நிபந்தனை-வடிவங்களுடன் மாற்றப்படுகிறது.

.c கோப்புகளை .o கோப்புகளாக நிரல்மொழிமாற்றிவதற்கு ஒரு பொதுவான பயன்பாட்டு வழக்கு. கையேடு(manual) வழி இங்கே:
#+begin_src makefile
objects = foo.o bar.o all.o
all: $(objects)
	$(CC) $^ -o all

foo.o: foo.c
	$(CC) -c foo.c -o foo.o

bar.o: bar.c
	$(CC) -c bar.c -o bar.o

all.o: all.c
	$(CC) -c all.c -o all.o

all.c:
	echo "int main() { return 0; }" > all.c

# குறிப்பு: all.c இந்த விதியைப் பயன்படுத்தாது (மேல் உள்ள விதி பயன்படுத்தும்), ஏனெனில் ஒன்றுக்கு மேற்பட்ட பொருத்தங்கள் இருக்கும்போது மேக் அதிக குறிப்பிட்ட(specific) பொருத்தங்களுக்கு முன்னுரிமை அளிக்கிறது.
%.c:
	touch $@

clean:
	rm -f *.c *.o all
#+end_src
நிலையான வடிவ விதியைப் பயன்படுத்த, மிகவும் திறமையான வழி இங்கே:
#+begin_src makefile
objects = foo.o bar.o all.o
all: $(objects)
	$(CC) $^ -o all

# தொடரியல் - இலக்குகள்...: இலக்கு-வடிவம்: முன்நிபந்தனை-வடிவங்கள் ...
# முதல் இலக்கான foo.o இன் விஷயத்தில், இலக்கு-வடிவமான foo.o உடன் பொருந்துகிறது மற்றும் "தண்டு" "foo" ஆக அமைக்கிறது.
# பின்னர் அது முன்நிபந்தனை-வடிவங்களில் உள்ள '%' ஐ அந்த தண்டுடன் மாற்றுகிறது
$(objects): %.o: %.c
	$(CC) -c $^ -o $@

all.c:
	echo "int main() { return 0; }" > all.c

# குறிப்பு: all.c இந்த விதியைப் பயன்படுத்தாது (மேல் உள்ள விதி பயன்படுத்தும்), ஏனெனில் ஒன்றுக்கு மேற்பட்ட பொருத்தங்கள் இருக்கும்போது மேக் அதிக குறிப்பிட்ட(specific) பொருத்தங்களுக்கு முன்னுரிமை அளிக்கிறது.
%.c:
	touch $@

clean:
	rm -f *.c *.o all
#+end_src
** நிலையான வடிவ விதிகள் (Static Pattern Rules) மற்றும் வடிகட்டி(Filters)
நான் வடிகட்டி செயல்பாட்டை பின்னர் அறிமுகப்படுத்தும்போது, ​​நிலையான வடிவ விதிகளில் பயன்படுத்துவது பொதுவானது, எனவே அதை இங்கே குறிப்பிடுகிறேன். சரியான கோப்புகளுடன் பொருந்த, நிலையான வடிவ விதிகளில் வடிகட்டி செயல்பாட்டைப் பயன்படுத்தலாம். இந்த எடுத்துக்காட்டில், நான் .raw மற்றும் .result விரிவாக்கங்களை(extension) உருவாக்கினேன்.

#+begin_src makefile
obj_files = foo.result bar.o lose.o
src_files = foo.raw bar.c lose.c

all: $(obj_files)
# குறிப்பு: PHONY இங்கே முக்கியமானது. இது இல்லாமல், முன்நிபந்தனைகள் ".o" கோப்புகளாக இருப்பதால், மறைமுக விதிகளால் இயங்கக்கூடிய "all" உருவாக்க முயற்சிக்கும்.
.PHONY: all 

# Ex 1: .o கோப்புகள் .c கோப்புகளைப் பொறுத்தது. நாம் உண்மையில் .o கோப்பை உருவாக்கவில்லை என்றாலும்.
$(filter %.o,$(obj_files)): %.o: %.c
	echo "target: $@ prereq: $<"

# Ex 2: .result கோப்புகள் .raw கோப்புகளைப் பொறுத்தது. நாம் உண்மையில் .result கோப்பை உருவாக்கவில்லை என்றாலும்
$(filter %.result,$(obj_files)): %.result: %.raw
	echo "target: $@ prereq: $<" 

%.c %.raw:
	touch $@

clean:
	rm -f $(src_files)
#+end_src

** வடிவ விதிகள்(Pattern Rules)

வடிவ விதிகள் பெரும்பாலும் பயன்படுத்தப்படுகின்றன ஆனால் மிகவும் குழப்பமானவை. நீங்கள் அவற்றை இரண்டு வழிகளில் பார்க்கலாம்:

- உங்கள் சொந்த மறைமுக விதிகளை வரையறுக்க ஒரு வழி
- நிலையான வடிவ விதிகளின்(Static Pattern Rules) எளிமையான வடிவம்

முதலில் ஒரு உதாரணத்துடன் ஆரம்பிக்கலாம்
#+begin_src makefile
# ஒவ்வொரு .c கோப்பையும் ஒரு .o கோப்பாக நிரல்மொழிமாற்றும் மாதிரி விதியை வரையறுக்கவும்
%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
#+end_src

வடிவ விதிகளில் இலக்கில் '%' உள்ளது. இந்த '%' எந்த காலியாக இல்லாத சரமுடன்(non empty string) பொருந்துகிறது, மற்ற எழுத்துக்கள் தங்களைப் பொருத்துகின்றன. ஒரு முறை விதியின் முன்நிபந்தனையில் '%' என்பது இலக்கில் உள்ள '%' உடன் பொருந்திய அதே தண்டைக்(stem) குறிக்கிறது.

இதோ மற்றொரு உதாரணம்:
#+begin_src makefile
# முன்நிபந்தனைகளில் எந்த வடிவமும் இல்லாத மாதிரி விதியை வரையறுக்கவும்.
# இது தேவைப்படும் போது வெற்று(empty) .c கோப்புகளை உருவாக்குகிறது.
%.c:
	touch $@
#+end_src

** இரட்டை முக்கால் புள்ளி விதிகள்(Double Colon rules)
இரட்டை முக்கால் புள்ளி விதிகள் அரிதாகவே பயன்படுத்தப்படுகின்றன, ஆனால் ஒரே இலக்குக்கு பல விதிகளை வரையறுக்க அனுமதிக்கின்றன. இவை ஒற்றை முக்கால் புள்ளி ஆக இருந்தால், ஒரு எச்சரிக்கை அச்சிடப்பட்டு, இரண்டாவது கட்டளைகள் மட்டுமே இயங்கும்.
#+begin_src makefile
all: blah

blah::
	echo "hello"

blah::
	echo "hello again"
#+end_src
* கட்டளைகள் மற்றும் செயல்படுத்தல் (Commands and Execution)
** கட்டளை எதிரொலி / அமைதிப்படுத்துதல் (Command Echoing/Silencing)
ஒரு கட்டளை அச்சிடப்படுவதை நிறுத்துவதற்கு, கட்டளைக்கு முன் @ ஐச் சேர்க்கவும்
ஒவ்வொரு வரிக்கும் முன்பு @ ஐச் சேர்க்க, நீங்கள் -s உடன் make ஐ இயக்கலாம்
#+begin_src makefile
all: 
	@echo "This make line will not be printed"
	echo "But this will"	 
#+end_src
** கட்டளை செயல்படுத்தல் (Command Execution)
ஒவ்வொரு கட்டளையும் ஒரு புதிய ஷெல்லில்(shell) இயக்கப்படுகிறது (அல்லது குறைந்த பட்சம் விளைவு இப்படி இருக்கும்)
#+begin_src makefile
all: 
	cd ..
	# மேலே உள்ள cd இந்த வரியை பாதிக்காது, ஏனெனில் ஒவ்வொரு கட்டளையும் ஒரு புதிய ஷெல்லில் திறம்பட இயங்கும்
	echo `pwd`

	# இந்த cd கட்டளை அடுத்ததை பாதிக்கிறது, ஏனெனில் அவை ஒரே வரியில் உள்ளன
	cd ..;echo `pwd`

	# மேலே உள்ளது
	cd ..; \
	echo `pwd`	  
#+end_src

** இயல்புநிலை கூடு (Default Shell)
இயல்புநிலை கூடு என்பது /bin/sh ஆகும். மாறி SHELL மாற்றுவதன் மூலம் இதை மாற்றலாம்:
#+begin_src makefile
SHELL=/bin/bash

cool:
	echo "Hello from bash"
#+end_src

** இரட்டை டாலர் அடையாளம் (Double Dollar Sign)
ஒரு சரம் டாலர் அடையாளத்தைக் கொண்டிருக்க வேண்டுமெனில், நீங்கள் $$ ஐப் பயன்படுத்தலாம். பாஷ்(bash) அல்லது ஷில்(sh) கூடு மாறியைப் (shell variable) பயன்படுத்துவது இதுதான்.

இந்த அடுத்த எடுத்துக்காட்டில் மேக் கோப்பு மாறிகள்(Makefile variable) மற்றும் கூடு மாறிகள்(Shell variable) இடையே உள்ள வேறுபாடுகளைக் கவனியுங்கள்.

#+begin_src makefile
make_var = I am a make variable
all:
	# கூடுயில் "sh_var='I am a shell variable'; echo $sh_var" இயங்குவது போலவே
	sh_var='I am a shell variable'; echo $$sh_var

	# கூடுயில் "echo I am a make variable" இயங்குவது போலவே
	echo $(make_var)
#+end_src

** பிழை கையாளுதல் -k, -i, மற்றும் -
- இயங்கும் போது -k ஐச் சேர், பிழைகள் ஏற்பட்டாலும் தொடர்ந்து இயங்கச் செய்யுங்கள். மேக்கின் அனைத்து பிழைகளையும் ஒரே நேரத்தில் பார்க்க விரும்பினால் உதவியாக இருக்கும்.
- பிழையை ஒடுக்க(suppress) ஒரு கட்டளைக்கு முன் ஒரு - ஐச் சேர்க்கவும்
- ஒவ்வொரு கட்டளைக்கும் பிழையை ஒடுக்குவதற்கு -i ஐ மேக் உடன் சேர்க்கவும்.

#+begin_src makefile
one:
	# இந்தப் பிழை அச்சிடப்படும், ஆனால் புறக்கணிக்கப்பட்டு, மேலும் மேக் தொடர்ந்து இயங்கும்
	-false
	touch one
#+end_src

** மேக் குறுக்கீடுதல் அல்லது அழித்தல் (Interrupting or killing make)

குறிப்பு மட்டும்: நீங்கள் ctrl+c ஐ மேக் இயங்குபோது கூடுத்தால், அது உருவாக்கிய புதிய இலக்குகளை நீக்கிவிடும்.


** மேக்கில் மீள்சுருள் பயன்பாடு (Recursive use of make)

மேக் கோப்பை மீண்டும் மீண்டும் அழைக்க, மேக்கிற்குப் பதிலாக பிரத்யேக $(MAKE) ஐப் பயன்படுத்தவும், ஏனெனில் அது உங்களுக்கான மேக் கொடிகளை சேர்த்து அனுப்பும் மற்றும் அவற்றால் பாதிக்கப்படாது.

#+begin_src makefile
new_contents = "hello:\n\ttouch inside_file"
all:
	mkdir -p subdir
	printf $(new_contents) | sed -e 's/^ //' > subdir/makefile
	cd subdir && $(MAKE)

clean:
	rm -rf subdir	  
#+end_src

** மேக்கில் ஏற்றுமதி, சூழல்கள் மற்றும் மீள்சுருள் (Export, Environments and Recursive make)

மேக் தொடங்கும் போது, எந்த சூழல் மாறிகள்(Environment variable) நிறுவப்பட்டு உள்ளதோ அது மேக் மாறிகளாக தானாகவே உருவாக்குகிறது.

#+begin_src makefile
# இதை "export shell_env_var='I am an environment variable'; make" உடன் இயக்கவும்
all:
	# கூடு மாறியை(shell variable) அச்சிடவும்
	echo $$shell_env_var

	# மேக் மாறியை அச்சிடவும்
	echo $(shell_env_var)	  
#+end_src

ஏற்றுமதி நெறியுறுத்தல்(export directive) ஒரு மாறியை எடுத்து அனைத்து தயாரிப்பு முறைகளிலும்(recipes) உள்ள அனைத்து கூடு கட்டளைகளுக்கும்(shell variable) சூழலை(environment) அமைக்கிறது:

#+begin_src makefile
shell_env_var=Shell env var, created inside of Make
export shell_env_var
all:
	echo $(shell_env_var)
	echo $$shell_env_var
#+end_src

எனவே, நீங்கள் மேக் இன் உள்ளே மேக் கட்டளையை இயக்கும் போது, ​​நீங்கள் ஏற்றுமதி நெறியுறுத்தல் பயன்படுத்தி துணை-மேக்(sub-make) கட்டளைகளை அணுகலாம். இந்த எடுத்துக்காட்டில், துணை கோப்புறை(sub directory) உள்ள மேக் கோப்பை பயன்படுத்தும் வகையில் cooly ஏற்றுமதி செய்யப்படுகிறது

#+begin_src makefile
new_contents = "hello:\n\techo \$$(cooly)"

all:
	mkdir -p subdir
	printf $(new_contents) | sed -e 's/^ //' > subdir/makefile
	@echo "---MAKEFILE CONTENTS---"
	@cd subdir && cat makefile
	@echo "---END MAKEFILE CONTENTS---"
	cd subdir && $(MAKE)

# மாறிகள் மற்றும் ஏற்றுமதிகள் என்பதை நினைவில் கொள்க. அவை பொதுவாக(globally) அமைக்கப்பட்டுள்ளன/பாதிக்கப்படுகின்றன.
cooly = "The subdirectory can see me!"
export cooly
# இது மேலே உள்ள வரியை ரத்து செய்யும்: cooly ஏற்றுமதியை நீக்கவும்

clean:
	rm -rf subdir
#+end_src

கூடுகாலிலும் இயங்குவதற்கு மாறிகளை ஏற்றுமதி செய்ய வேண்டும்.

#+begin_src makefile
one=this will only work locally
export two=we can run subcommands with this

all: 
	@echo $(one)
	@echo $$one
	@echo $(two)
	@echo $$two
#+end_src

.EXPORT_ALL_VARIABLES உங்களுக்கான அனைத்து மாறிகளையும் ஏற்றுமதி செய்கிறது.

#+begin_src makefile
.EXPORT_ALL_VARIABLES:
new_contents = "hello:\n\techo \$$(cooly)"

cooly = "The subdirectory can see me!"
# இது மேலே உள்ள வரியை ரத்து செய்யும்: cooly ஏற்றுமதியை நீக்கவும்

all:
	mkdir -p subdir
	printf $(new_contents) | sed -e 's/^ //' > subdir/makefile
	@echo "---MAKEFILE CONTENTS---"
	@cd subdir && cat makefile
	@echo "---END MAKEFILE CONTENTS---"
	cd subdir && $(MAKE)

clean:
	rm -rf subdir
#+end_src

** மேக்கின் தருமதிப்புகள்
மேக் இருந்து இயக்கக்கூடிய விருப்பங்களின் நல்ல பட்டியல் உள்ளது. --dry-run, --touch, --old-file ஐ பார்க்கவும்.

நீங்கள் மேக் மூலம் பல இலக்குகளை இயக்கலாம் i.e make clean run test அது clean முதலில் பின் run பின் test யை செயல்படுத்தும்

* மாறிகள் பகுதி 2
