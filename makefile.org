#+title: Makefile Tutorial By Example
#+author: Translated by Thanga Ayyanar

நான் இந்த வழிகாட்டியை உருவாக்கினேன், ஏனென்றால் என்னால் மேக் கோப்பு (Makefile) பற்றி சுற்றிக்கொள்ள கடினமாக இருந்ததால். அவைகளில் மறைந்திருக்கும் விதிகள் மற்றும் மறைமுகமான சின்னங்களைக் கொண்டு இருக்கிறது, மேலும் எளிமையான கேள்விக்கு எளிமையான பதில்களைக் கொடுக்கவில்லை. இதைத் தீர்க்க, நான் பல வார இறுதிகளில் அமர்ந்து மேக் கோப்பு பற்றி என்னால் முடிந்த அனைத்தையும் படித்தேன். இந்த வழிகாட்டியில் மிக முக்கியமான விஷயங்களை நான் சுருக்கி தொகுத்து உள்ளேன். ஒவ்வொரு தலைப்புக்கும் ஒரு சுருக்கமான விளக்கமும், சுயமாக இயங்கக்கூடிய ஒரு உதாரணமும் உள்ளது.

நீங்கள் பெரும்பாலும் மேக் ஐப் புரிந்து கொண்டால், மேக் கோப்பு பயனர் கையேடுவைப் (cookbook) பார்க்கவும், இதில் மேக் கோப்பு இன் ஒவ்வொரு பகுதியும் என்ன செய்கிறது என்பதைப் பற்றிய போதுமான கருத்துகளைக் கொண்ட நடுத்தர அளவிலான திட்டங்களுக்கான (project) படிம அச்சு(template) உள்ளது.

நல் வாழ்த்துக்கள், மேக் கோப்புகளின் குழப்பமான உலகத்தை உங்களால் புரிந்துகொள்ள முடியும் என்று நம்புகிறேன்!

* துவக்கம் ஆரம்பிக்கிறது

** மேக் கோப்புகள் ஏன் உள்ளன?
ஒரு பெரிய நிரலின் எந்தப் பகுதிகளை மறுநிரல்மொழிமாற்ற(recompile) வேண்டும் என்பதைத் தீர்மானிக்க மேக் கோப்புகள் பயன்படுத்தப்படுகின்றன. பெரும்பாலான சந்தர்ப்பங்களில், C அல்லது C++ கோப்புகள் நிரல்மொழிமாற்ற(compile) படுகின்றன. பிற மொழிகள் பொதுவாக மேக் போன்ற அதே சேவை செய்யும் சொந்த கருவிகளைக் கொண்டுள்ளன. மேக் நிரல்மொழிமாற்ற மட்டும் இல்லாமல் எந்த கோப்புகள் மாறிவிட்டன என்பதைப் பொறுத்து இயக்குவதற்கு உங்களுக்கு தொடர்ச்சியான வழிமுறைகள்(series of instruction) தேவைப்படும்போதும் பயன்படுத்தலாம். 

இந்த பயிற்சியில் C/C++ நிரல்மொழிமாற்ற பயன்பாட்டு விஷயத்தில் கவனம் செலுத்தும்.

மேக் மூலம் நீங்கள் உருவாக்கக்கூடிய சார்பு வரைபடம் (dependency graph) இங்கே உள்ளது. ஏதேனும் கோப்பின் சார்புகள்(dependency) மாறினால், கோப்பு மீண்டும் நிரல்மொழிமாற்றபடும்:

#+CAPTION: Sample dependency graph for make file
#+NAME:   fig:make-dependency-graph

[[./assets/dependency_graph.png]]

** மேக் மாற்றாக வேறு என்ன மென்பொருள் உள்ளன?
பிரபலமான C/C++ க்கு மாற்று உருவாக்க அமைப்புகள்(Build tools) SCons, CMake, Bazel மற்றும் Ninja ஆகும். மைக்ரோசாஃப்ட் விஷுவல் ஸ்டுடியோ(Microsoft Visual Studio) போன்ற சில குறியீடு தொகுப்பிகள்(code editors) தங்களுக்கென உள்ளமைக்கப்பட்ட கருவிகளைக் (inbuilt tools) கொண்டுள்ளனர். ஜாவாவிற்கு(Java), அன்ட் (Ant), மேவன்(Maven) மற்றும் கிரேடில்(Gradle) உள்ளன. கோ(Go), ரஸ்ட்(Rust) மற்றும் டைப்ஸ்கிரிப்ட்(Typescript) போன்ற பிற மொழிகள் அவற்றின் சொந்த உருவாக்கப்பட்ட கருவிகளைக் கொண்டுள்ளன.

பைதான்(Python), ரூபி(Ruby) மற்றும் ரா ஜாவாஸ்கிரிப்ட்(Raw Javascript) போன்ற நிரற்பெயர்ப்பி மொழிகளுக்கு (Interpreted language) மேக் கோப்பு தேவையில்லை. மேக் கோப்புபின் குறிக்கோள், எந்த கோப்புகள் மாறியுள்ளன என்பதை அடிப்படையாகக் கொண்டு நிரல்மொழிமாற்ற வேண்டிய கோப்புகளை நிரல்மொழிமாற்ற வேண்டும். ஆனால் நிரற்பெயர்ப்பி மொழிகளில் உள்ள கோப்புகள் மாறும்போது, ​​எதையும் மறுநிரல்மொழிமாற்ற வேண்டியதில்லை. நிரல் இயங்கும் போது, ​​கோப்பின் சமீபத்திய பதிப்புயை பயன்படுத்தப்படும்.

** மேக்கின் பதிப்புகள் மற்றும் வகைகள்
மேக்கின் பல்வேறு செயலாக்கங்கள்(implementation) உள்ளன, ஆனால் இந்த வழிகாட்டியில் பெரும்பாலானவை நீங்கள் பயன்படுத்தும் எந்தப் பதிப்பிலும்(version) வேலை செய்யும். இருப்பினும், இது குறிப்பாக குனு மேக்காக(GNU Make) எழுதப்பட்டது, இது லினக்ஸ் மற்றும் மாக்(Mac) இல் நிலையான செயலாக்கமாகும். அனைத்து எடுத்துக்காட்டுகளும் மேக் பதிப்புகள் 3 மற்றும் 4 க்கு வேலை செய்கின்றன, அவை சில மறைபொருள்(esoteric) வேறுபாடுகளைத் தவிர கிட்டத்தட்ட சமமானவை.

** எடுத்துக்காட்டுகளை இயக்குதல்
இந்த உதாரணங்களை இயக்க, உங்களுக்கு கட்டளை வரி(Terminal/Command Line) மற்றும் "மேக்" நிறுவயிருக்க வேண்டும். ஒவ்வொரு உதாரணத்திற்கும், ~Makefile~ எனப்படும் கோப்பில் உள்ளடக்கங்களை(contents) வைத்து, அந்த கோப்பகத்தில்(folder) மேக் கட்டளையை இயக்கவும். எளிமையான மேக் கோப்பு உடன் ஆரம்பிக்கலாம்:

#+begin_src makefile
hello:
	echo "Hello, World"
#+end_src

*குறிப்பு*: மேக் கோப்பு TABகளைப் பயன்படுத்தி உள்தள்ளப்பட(indent) வேண்டும், இடைவெளிகள்(space) பயன்படுத்தினால் make தோல்வியடையும்.

மேலே உள்ள உதாரணத்தை இயக்குவதன் வெளியீடு(output) இங்கே:
#+begin_src shell
$ make
echo "Hello, World"
Hello, World
#+end_src

அவ்வளவுதான்!

** மேக் கோப்பு தொடரியல்(Syntax)
ஒரு மேக் கோப்பு விதிகளின் தொகுப்பைக்(set of rules) கொண்டுள்ளது. ஒரு விதி பொதுவாக இது போல் இருக்கும்:
#+begin_src makefile
இலக்குகள்: முன்நிபந்தனைகள்
	கட்டளை
	கட்டளை
	கட்டளை	  
#+end_src
- இலக்குகள் கோப்பு பெயர்கள், இடைவெளிகளால்(space) பிரிக்கப்படுகின்றன. பொதுவாக, ஒரு விதிக்கு ஒன்று மட்டுமே இருக்க வேண்டும்.
- கட்டளைகள் என்பது இலக்கை (களை) உருவாக்க பொதுவாகப் பயன்படுத்தப்படும் படிகளின் வரிசையாகும்(series of steps). இவை Tab எழுத்துடன் தொடங்க வேண்டும், இடைவெளிகள்(space) அல்ல.
- முன்நிபந்தனைகள் கோப்பு பெயர்கள், இடைவெளிகளால் பிரிக்கப்படுகின்றன. இலக்குக்கான கட்டளைகளை இயக்கும் முன் இந்தக் கோப்புகள் இருக்க வேண்டும். இவை சார்புகள்(dependency) என்றும் அழைக்கப்படுகின்றன.

** மேக்கின் சாராம்சம்
ஒரு உலகத்திற்கு வணக்கம்(Hello world) உதாரணத்துடன் ஆரம்பிக்கலாம்:
#+begin_src makefile
hello:
	echo "Hello, World"
	echo "This line will print if the file hello does not exist."	  
#+end_src

ஏற்கனவே இங்கே கற்றுக்கொள்ள நிறைய இருக்கிறது. அதை ஒவ்வொன்றாக பார்க்கவும்:
- நம்மிடம் ~hello~ என்று ஒரு இலக்கு உள்ளது
- இந்த இலக்கு இரண்டு கட்டளைகளைக் கொண்டுள்ளது
- இந்த இலக்குக்கு முன்நிபந்தனைகள் எதுவும் இல்லை

நாம் ~make hello~ என்று இயக்குவோம். hello கோப்பு இல்லாத வரை, கட்டளைகள் இயங்கும். hello இருந்தால், எந்த கட்டளையும் இயங்காது.

நான் hello ஒரு இலக்கு மற்றும் ஒரு கோப்பு என்று பேசுகிறேன் என்பதை உணர வேண்டியது அவசியம். இரண்டும் நேரடியாக இணைந்திருப்பதே இதற்குக் காரணம். பொதுவாக, ஒரு இலக்கு இயக்கப்படும் போது (ஒரு இலக்கின் கட்டளைகள் இயக்கப்படும் போது), கட்டளைகள் இலக்கின் அதே பெயரில் ஒரு கோப்பை உருவாக்கும். இந்த வழக்கில், hello இலக்கு hello கோப்பை உருவாக்காது.

மிகவும் பொதுவான மேக் கோப்புகலை உருவாக்குவோம் - ஒரு சி கோப்பை நிரல்மொழிமாற்றும்(compile). ஆனால் நாம் அதை செய்வதற்கு முன், பின்வரும் உள்ளடக்கங்களைக் கொண்ட blah.c என்ற கோப்பை உருவாக்கவும்:
#+NAME: blah.c
#+begin_src c
// blah.c
#include<stdio.h>
int main() { 
  return 0; 
}
#+end_src
பின்னர் Makefile எனப்படும் கோப்புயை உருவாக்கவும். அதில் பின்வரும் உள்ளடக்கங்களை எழுதவும்.
#+begin_src makefile
blah:
	cc blah.c -o blah	  
#+end_src

இந்த நேரத்தில், make ஐ இயக்க முயற்சிக்கவும். மேக் கட்டளைக்கு தருமதிப்பு(argument) என எந்த இலக்கும் வழங்கப்படவில்லை என்பதால், முதல் இலக்கு இயக்கப்படுகிறது. இந்த வழக்கில், ஒரே ஒரு இலக்கு (blah) உள்ளது. நீங்கள் இதை முதல் முறையாக இயக்கும் போது, ​​blah உருவாக்கப்படும். இரண்டாவது முறை, நீங்கள் make இயக்கும் போது ~make: 'blah' is up to date~ என்று வரும். ஏனென்றால் blah கோப்பு ஏற்கனவே இருப்பதால் தான். ஆனால் ஒரு சிக்கல் உள்ளது: நாம் blah.c ஐ மாற்றியமைத்த, பின்னர் make ஐ இயக்கினால், எதுவும்  மறுநிரல்மொழிமாற்ற(recompile) படாது.

ஒரு முன்நிபந்தனையைச் சேர்ப்பதன் மூலம் இதை நாம் தீர்க்கிறோம்:
#+begin_src makefile
blah: blah.c
	cc blah.c -o blah	  
#+end_src
மீண்டும் make ஐ இயக்கும்போது, ​​பின்வரும் படிநிலைகள் நடக்கும்:

- முதல் இலக்கு தேர்ந்தெடுக்கப்பட்டது, ஏனெனில் முதல் இலக்கு இயல்புநிலை(default) இலக்காகும்
- இதற்கு blah.c இன் முன்நிபந்தனை உள்ளது
- அது blah இலக்கை இயக்க வேண்டுமா என்பதை முடிவு செய்யும். blah இல்லாவிட்டால் அல்லது blah.c, blah விட புதியதாக இருந்தால் மட்டுமே அது இயங்கும்

இந்த கடைசி படி முக்கியமானதாகும், மேலும் இது make இன் சாராம்சமாகும். அது என்ன செய்ய முயற்சிக்கிறது என்றால் blah கடைசியாக நிரல்மொழிமாற்ற பட்டதிலிருந்து blah முன்நிபந்தனைகள் மாறியிருக்கிறதா என்று. அதாவது, blah.c மாற்றியமைக்கப்பட்டால், மேக் கோப்பை மறுநிரல்மொழிமாற்ற(recompile) வேண்டும். மற்றும் மாறாக, blah.c மாறவில்லை என்றால், அது மறுநிரல்மொழிமாற்ற(recompile) கூடாது.

இதைச் செய்ய, கோப்பமைப்பு நேர முத்திரைகளை(Timestamp) பதிலியாக(proxy) பயன்படுத்தி ஏதாவது மாற்றம் ஏற்பட்டுள்ளதா என்பதைத் தீர்மானிக்கிறது. இது ஒரு நியாயமான பட்டறிவுசார்(heuristic) ஆகும், ஏனெனில் கோப்பு நேர முத்திரைகள் பொதுவாக கோப்புகள் மாற்றப்பட்டால் மட்டுமே மாறும். ஆனால் இது எப்போதும் இப்படி இருக்காது என்பதை உணர வேண்டியது அவசியம். உதாரணமாக, நீங்கள் ஒரு கோப்பை மாற்றலாம், பின்னர் அந்தக் கோப்பின் மாற்றியமைக்கப்பட்ட நேர முத்திரையை பழையதாக மாற்றலாம். நீங்கள் அவ்வாறு செய்தால், கோப்பு மாறவில்லை என்று மேக் தவறாக யூகித்து, இயக்கத்தை புறக்கணிக்கப்படலாம்.

இதை நீங்கள் புரிந்துகொள்வதை உறுதிப்படுத்திக் கொள்ளுங்கள். இது Makefiles இன் முக்கிய அம்சமாகும், மேலும் நீங்கள் சரியாகப் புரிந்துகொள்ள சில நிமிடங்கள் ஆகலாம். மேலே உள்ள உதாரணங்களுடன் விளையாடுங்கள்.

** மேலும் விரைவான எடுத்துக்காட்டுகள்

பின்வரும் மேக் கோப்பு இறுதியில் மூன்று இலக்குகளையும் இயக்குகிறது. நீங்கள் கட்டளை வரியில்(Terminal/Command Line) make ஐ இயக்கும் போது, ​​அது தொடர்ச்சியான படிகளில் blah எனப்படும் நிரலை உருவாக்கும்:

- இலக்கு blah ஐ Make தேர்வு செய்கிறது, ஏனெனில் முதல் இலக்கு இயல்புநிலை(default) இலக்காகும்
- blah க்கு blah.o தேவைப்படுகிறது, எனவே blah.o இலக்கைத் தேடுகிறது
- blah.o க்கு blah.c தேவைப்படுகிறது, எனவே blah.c இலக்கைத் தேடுகிறது
- blah.c க்கு சார்புகள்(dependency) இல்லை, எனவே echo கட்டளை இயக்கப்படுகிறது
- cc -c கட்டளை இயக்கப்படுகிறது, ஏனெனில் blah.o சார்புகள் அனைத்தும் முடிந்துவிட்டன
- மேல் cc கட்டளை இயக்கப்படுகிறது, ஏனெனில் அனைத்து blah சார்புகளும் முடிந்துவிட்டன
- அவ்வளவுதான்: blah ஒரு நிரல்மொழிமாற்ற பட்ட c நிரல்
#+begin_src makefile
blah: blah.o
	cc blah.o -o blah # முன்றாவது ஆக இயங்கும்

blah.o: blah.c
	cc -c blah.c -o blah.o # இரண்டாவது ஆக இயங்கும்

# பொதுவாக blah.c ஏற்கனவே இருக்கும், ஆனால் தேவையான கூடுதல் கோப்புகளை நான் குறைக்க விரும்புகிறேன்
blah.c:
	echo "int main() { return 0; }" > blah.c # முதலில் இயங்கும்	  
#+end_src

நீங்கள் blah.c ஐ நீக்கினால், மூன்று இலக்குகளும் மீண்டும் இயக்கப்படும். நீங்கள் அதைத் திருத்தினால் (இதனால் நேர முத்திரையை blah.o ஐ விட புதியதாக மாறும்), முதல் இரண்டு இலக்குகள் இயங்கும். நீங்கள் touch blah.o ஐ இயக்கினால் (இதனால் நேர முத்திரையை blah ஐ விட புதியதாக மாறும்), பிறகு முதல் இலக்கு மட்டுமே இயங்கும். நீங்கள் எதையும் மாற்றவில்லை என்றால், இலக்குகள் எதுவும் இயங்காது. முயற்சி செய்து பாருங்கள்!

இந்த அடுத்த உதாரணம் புதிதாக எதையும் செய்யவில்லை, இருப்பினும் இது ஒரு நல்ல கூடுதல் எடுத்துக்காட்டு. இது எப்போதும் இரண்டு இலக்குகளையும் இயக்கும், ஏனெனில் some_file other_file சார்ந்தது, அது எப்போதும் கோப்பை உருவாக்காது.
#+begin_src makefile
some_file: other_file
	echo "This will always run, and runs second"
	touch some_file

other_file:
	echo "This will always run, and runs first"	  
#+end_src

** மேக் கிளீன் (make clean)

clean என்பது பெரும்பாலும் மற்ற இலக்குகளின் வெளியீட்டை(output) அகற்றும் இலக்காகப் பயன்படுத்தப்படுகிறது, ஆனால் இது மேக் என்பதில் ஒரு சிறப்புச் சொல் அல்ல. some_file உருவாக்க மற்றும் நீக்க, இதில் make மற்றும் make clean இயக்கலாம்.

கிளீன்(clean) இங்கே இரண்டு புதிய விஷயங்களைச் செய்கிறது என்பதை நினைவில் கொள்க:

- இது முதலில் இல்லாத ஒரு இலக்கு (இயல்புநிலை), மற்றும் இதற்கு முன்நிபந்தனை அல்ல. அதாவது make clean என்று நீங்கள் வெளிப்படையாக அழைக்கும் வரை இது இயங்காது
- இது ஒரு கோப்பு பெயராக இருக்கவில்லை. உங்களிடம் ஒரு கோப்பு clean என்று இருந்தால், இந்த இலக்கு இயங்காது, அது நாம் விரும்புவதில்லை. இதை எப்படி சரிசெய்வது என்பது குறித்த இந்த பயற்சியில் .PHONYஐப் என்று பிறகு பார்ப்போம்.

#+begin_src makefile
some_file: 
	touch some_file

clean:
	rm -f some_file	  
#+end_src

** மாறிகள்(variables)
மாறிகள் சரங்களாக(string) மட்டுமே இருக்க முடியும். நீங்கள் பொதுவாக := ஐப் பயன்படுத்துவோம், ஆனால் = ஏன் வேலை செய்கிறது. மாறிகள் பாகம் 2 ஐப் பார்க்கவும்.

மாறிகளைப் பயன்படுத்துவதற்கான எடுத்துக்காட்டு இங்கே:
#+begin_src makefile
files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file	  
#+end_src
ஒற்றை அல்லது இரட்டை மேற்கோள்களுக்கு(quotes) அர்த்தம் இல்லை மேக்கில். அவை வெறுமனே மாறிக்கு ஒதுக்கப்பட்ட எழுத்துக்கள். மேற்கோள்கள் கூடு(shell)/பாஷுக்கு(Bash) பயனுள்ளதாக இருக்கும், மேலும் அவை உங்களுக்கு printf போன்ற கட்டளைகளில் தேவைப்படும். இந்த எடுத்துக்காட்டில், இரண்டு கட்டளைகளும் ஒரே மாதிரியாக செயல்படுகின்றன:
#+begin_src makefile
a := one two # a ஆனது "one two" என்ற சரத்திற்கு அமைக்கப்பட்டுள்ளது
b := 'one two' # பரிந்துரைக்கப்படவில்லை. b ஆனது "'one two'" சரத்திற்கு அமைக்கப்பட்டுள்ளது
all:
	printf '$a'
	printf $b
#+end_src
மாறிகளைப் பயன்படுத்த ${} அல்லது $()
#+begin_src makefile
x := dude

all:
	echo $(x)
	echo ${x}

	echo $x # தவறான நடைமுறை, ஆனால் வேலை செய்கிறது
#+end_src

* இலக்குகள் (Targets)
** all இலக்கு
பல இலக்குகளை உருவாக்கி, அவை அனைத்தும் இயங்க வேண்டுமா? all இலக்கை உருவாக்குங்கள். இது பட்டியலிடப்பட்ட முதல் விதி என்பதால், இலக்கைக் குறிப்பிடாமல் make என்று அழைக்கப்பட்டால் அது இயல்பாகவே இயங்கும்.
#+begin_src makefile
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
#+end_src

** பல இலக்குகள் (Multiple targets)
ஒரு விதிக்கு பல இலக்குகள் இருக்கும்போது, ​​ஒவ்வொரு இலக்கிற்கும் கட்டளைகள் இயக்கப்படும். $@ என்பது இலக்கு பெயரைக் கொண்ட ஒரு தானியங்கி மாறி(automatic variable).
#+begin_src makefile
all: f1.o f2.o

f1.o f2.o:
	echo $@
# இதற்கு சமம்:
# f1.o:
#	 echo f1.o
# f2.o:
#	 echo f2.o
#+end_src

* தானியங்கி மாறிகள் மற்றும் குழுக்குறிகள் (Automatic variables and wildcards)
** * குழுக்குறி

மேக்கில் * மற்றும் % ஆகிய இரண்டும் குழுக்குறிகள் என்று அழைக்கப்படுகின்றன, ஆனால் அவை முற்றிலும் வேறுபட்ட விஷயங்களைக் குறிக்கின்றன. * பொருந்தக்கூடிய கோப்புப் பெயர்களுக்கு உங்கள் கோப்பமைப்புத்(file system) தேடுகிறது. நீங்கள் எப்போதும் குழுக்குறி செயல்பாட்டில்(function) குழுக்குறியை மடிக்குமாறு(wrap) நான் பரிந்துரைக்கிறேன், இல்லையெனில் கீழே விவரிக்கப்பட்டுள்ள பொதுவான சிக்கலில் நீங்கள் விழலாம்.

#+begin_src makefile
# ஒவ்வொரு .c கோப்பு பற்றிய கோப்பு தகவலை அச்சிடவும்
print: $(wildcard *.c)
	ls -la  $?
#+end_src

\* இலக்கு, முன்நிபந்தனைகள் அல்லது குழுக்குறி செயல்பாட்டில் பயன்படுத்தப்படலாம்.

ஆபத்து: * மாறி வரையறைகளில் நேரடியாகப் பயன்படுத்தப்படாமல் இருக்கவும்
ஆபத்து: * கோப்புகளுடன் பொருந்தவில்லை என்றால், அது அப்படியே விடப்படும் (வைல்டு கார்டு செயல்பாட்டில் இயங்காத வரை)

#+begin_src makefile
thing_wrong := *.o #இதை செய்யாதே! '*' விரிவாக்கப்படாது
thing_right := $(wildcard *.o)

all: one two three four

# தோல்வி, ஏனெனில் $(thing_wrong) என்பது சரம் "*.o"
one: $(thing_wrong)


# இந்த வடிவத்துடன் பொருந்தக்கூடிய கோப்புகள் இல்லை என்றால் *.o ஆக இருக்கும் :(
two: *.o 

# நீங்கள் எதிர்பார்ப்பது போல் வேலை செய்கிறது! இந்த நிலையில், அது எதுவும் செய்யாது.
three: $(thing_right)

# விதி மூன்று போலவே
four: $(wildcard *.o)	  
#+end_src

** % குழுக்குறி
% உண்மையில் பயனுள்ளது, ஆனால் இது பல்வேறு சூழ்நிலைகளில் பயன்படுத்தப்படுவதால் சற்றே குழப்பமாக இருக்கும்.

- "பொருந்தும்"(macthing) பயன்முறையில் பயன்படுத்தப்படும் போது, ​​அது ஒரு சரத்தில் ஒன்று அல்லது அதற்கு மேற்பட்ட எழுத்துகளுடன் பொருந்தும். இந்த பொருத்தம் தண்டு(stem) என்று அழைக்கப்படுகிறது.
- "மாற்று"(replacing) பயன்முறையில் பயன்படுத்தப்படும் போது, ​​அது பொருந்திய தண்டை எடுத்து ஒரு சரத்தில் மாற்றுகிறது.
- % பெரும்பாலும் விதி வரையறைகளிலும்(rule definitions) சில குறிப்பிட்ட செயல்பாடுகளிலும் பயன்படுத்தப்படுகிறது.

இது பயன்படுத்தப்பட்டதற்கான எடுத்துக்காட்டுகளில் இந்த பிரிவுகளைப் பார்க்கவும்:

- நிலையான வடிவ விதிகள் (Static Pattern Matching)
- வடிவ விதிகள் (Pattern matching)
- சரம் மாற்று (String Subtitution)
- vpath நெறியுறுத்தம் (The vpath directive)

** தானியங்கி மாறிகள் (Automatic variable)
பல தானியங்கி மாறிகள் உள்ளன, ஆனால் பெரும்பாலும் சில மட்டுமே காண்பிக்கப்படுகின்றன:
#+begin_src makefile
hey: one two
	# இது இலக்கு பெயர் என்பதால், "hey" வெளியீடுகள்
	echo $@

	# இலக்கை விட புதியதாக இருக்கும் அனைத்து முன்நிபந்தனைகளையும் வெளியிடுகிறது
	echo $?

	# அனைத்து முன்நிபந்தனைகளையும் வெளியிடுகிறது
	echo $^

	# முதல் முன்நிபந்தனையை வெளியிடுகிறது
	echo $<

	touch hey

one:
	touch one

two:
	touch two

clean:
	rm -f hey one two
#+end_src

* ஆடம்பரமான விதிகள்
** மறைமுக விதிகள் (implicit rules)

மேக் க்கு சி நிரல்மொழி மாற்றுதல் மிகவும் பிடிக்கும். ஒவ்வொரு முறையும் அது தன் அன்பை வெளிப்படுத்தும் போது, ​​விஷயங்கள் குழப்பமடைகின்றன. ஒருவேளை மேக்கின் மிகவும் குழப்பமான பகுதி மேஜிக்/தானியங்கி விதிகள்(Automatic rules) ஆகும். இந்த "மறைமுகமான" விதிகளை என்றும் அழைக்கபடுகின்றன. இந்த வடிவமைப்பு முடிவை(design decision) நான் தனிப்பட்ட முறையில் ஏற்கவில்லை, மேலும் அவற்றைப் பயன்படுத்த நான் பரிந்துரைக்கவில்லை, ஆனால் அவை அடிக்கடி பயன்படுத்தப்படுகின்றன, எனவே தெரிந்துகொள்வது பயனுள்ளதாக இருக்கும். மறைமுக விதிகளின் பட்டியல் இங்கே:

- ஒரு C நிரலைத் நிரல்மொழிமாற்றுதல்: ~$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@~ என்ற படிவத்தின் கட்டளையுடன் n.c இலிருந்து n.o தானாகவே உருவாக்கப்படுகிறது.
- C++ நிரலைத் நிரல்மொழிமாற்றுதல்: ~$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@~ என்ற படிவத்தின் கட்டளையுடன் n.cc அல்லது n.cpp இலிருந்து n.o தானாகவே உருவாக்கப்படுகிறது.
- ஒற்றை பொருள்(object) கோப்பை இணைக்க(linking): ~$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@~ கட்டளையை இயக்குவதன் மூலம் n.o இலிருந்து n தானாகவே உருவாக்கப்படுகிறது.

மறைமுக விதிகளால் பயன்படுத்தப்படும் முக்கியமான மாறிகள்:

 CC: C நிரல்களை நிரல்மொழிமாற்று வதற்கான நிரல்; இயல்புநிலை(default) cc
 CXX: C++ நிரல்களைத் நிரல்மொழிமாற்று வதற்கான நிரல்; இயல்புநிலை(default) g++
 CFLAGS: C கம்பைலருக்கு கொடுக்க கூடுதல் கொடிகள்
 CXXFLAGS: C++ நிரல்மொழிமாற்றிக்கு கொடுக்க கூடுதல் கொடிகள்
 CPPFLAGS: C நிரல்மொழிமாற்றிக்கு கொடுக்க கூடுதல் கொடிகள்
 LDFLAGS: நிரல்மொழிமாற்றிகள் இணைப்பாளரைத்(Linker) தூண்டும் போது கொடுக்க வேண்டிய கூடுதல் கொடிகள்

இப்போது நாம் எப்படி C நிரலை உருவாக்குவது என்று பார்ப்போம், நிரல்மொழிமாற்றிதல் எப்படி செய்வது என்று வெளிப்படையாகச் சொல்லாமல்:
#+begin_src makefile
CC = gcc # மறைமுக விதிகளுக்கான கொடி
CFLAGS = -g # மறைமுக விதிகளுக்கான கொடி. பிழைத்திருத்தத் தகவலை இயக்கவும்

# மறைமுக விதி #1: சி இணைப்பான் மறைமுக விதி வழியாக blah உருவக்கப்பட்டது
# மறைமுக விதி #2: blah.o ஆனது C நிரல்மொழிமாற்றியின் மறைமுக விதியின் மூலம் உருவக்கப்பட்டது, ஏனெனில் blah.c ஏற்கனவே இருக்கிறது
blah: blah.o

blah.c:
	echo "int main() { return 0; }" > blah.c

clean:
	rm -f blah*
#+end_src

** நிலையான வடிவ விதிகள் (Static Pattern Rules)

நிலையான வடிவ விதிகள் மேக் கோப்பு குறைவாக எழுத மற்றொரு வழி. இதோ அவைகளின் தொடரியல்(syntax):
#+begin_src makefile
இலக்குகள்...: இலக்கு-வடிவம்: முன்நிபந்தனை-வடிவங்கள் ...
 கட்டளைகள்
#+end_src

சாராம்சம் என்னவென்றால், கொடுக்கப்பட்ட இலக்கு இலக்கு-வடிவத்துடன் (% குழுக்குறி வழியாக) பொருந்துகிறது. எது பொருந்தியதோ அது தண்டு(stem) எனப்படும். இலக்கின் முன்நிபந்தனைகளை உருவாக்க, தண்டு முன்நிபந்தனை-வடிவங்களுடன் மாற்றப்படுகிறது.

.c கோப்புகளை .o கோப்புகளாக நிரல்மொழிமாற்றிவதற்கு ஒரு பொதுவான பயன்பாட்டு வழக்கு. கையேடு(manual) வழி இங்கே:
#+begin_src makefile
objects = foo.o bar.o all.o
all: $(objects)
	$(CC) $^ -o all

foo.o: foo.c
	$(CC) -c foo.c -o foo.o

bar.o: bar.c
	$(CC) -c bar.c -o bar.o

all.o: all.c
	$(CC) -c all.c -o all.o

all.c:
	echo "int main() { return 0; }" > all.c

# குறிப்பு: all.c இந்த விதியைப் பயன்படுத்தாது (மேல் உள்ள விதி பயன்படுத்தும்), ஏனெனில் ஒன்றுக்கு மேற்பட்ட பொருத்தங்கள் இருக்கும்போது மேக் அதிக குறிப்பிட்ட(specific) பொருத்தங்களுக்கு முன்னுரிமை அளிக்கிறது.
%.c:
	touch $@

clean:
	rm -f *.c *.o all
#+end_src
நிலையான வடிவ விதியைப் பயன்படுத்த, மிகவும் திறமையான வழி இங்கே:
#+begin_src makefile
objects = foo.o bar.o all.o
all: $(objects)
	$(CC) $^ -o all

# தொடரியல் - இலக்குகள்...: இலக்கு-வடிவம்: முன்நிபந்தனை-வடிவங்கள் ...
# முதல் இலக்கான foo.o இன் விஷயத்தில், இலக்கு-வடிவமான foo.o உடன் பொருந்துகிறது மற்றும் "தண்டு" "foo" ஆக அமைக்கிறது.
# பின்னர் அது முன்நிபந்தனை-வடிவங்களில் உள்ள '%' ஐ அந்த தண்டுடன் மாற்றுகிறது
$(objects): %.o: %.c
	$(CC) -c $^ -o $@

all.c:
	echo "int main() { return 0; }" > all.c

# குறிப்பு: all.c இந்த விதியைப் பயன்படுத்தாது (மேல் உள்ள விதி பயன்படுத்தும்), ஏனெனில் ஒன்றுக்கு மேற்பட்ட பொருத்தங்கள் இருக்கும்போது மேக் அதிக குறிப்பிட்ட(specific) பொருத்தங்களுக்கு முன்னுரிமை அளிக்கிறது.
%.c:
	touch $@

clean:
	rm -f *.c *.o all
#+end_src
** நிலையான வடிவ விதிகள் (Static Pattern Rules) மற்றும் வடிகட்டி(Filters)
நான் வடிகட்டி செயல்பாட்டை பின்னர் அறிமுகப்படுத்தும்போது, ​​நிலையான வடிவ விதிகளில் பயன்படுத்துவது பொதுவானது, எனவே அதை இங்கே குறிப்பிடுகிறேன். சரியான கோப்புகளுடன் பொருந்த, நிலையான வடிவ விதிகளில் வடிகட்டி செயல்பாட்டைப் பயன்படுத்தலாம். இந்த எடுத்துக்காட்டில், நான் .raw மற்றும் .result விரிவாக்கங்களை(extension) உருவாக்கினேன்.

#+begin_src makefile
obj_files = foo.result bar.o lose.o
src_files = foo.raw bar.c lose.c

all: $(obj_files)
# குறிப்பு: PHONY இங்கே முக்கியமானது. இது இல்லாமல், முன்நிபந்தனைகள் ".o" கோப்புகளாக இருப்பதால், மறைமுக விதிகளால் இயங்கக்கூடிய "all" உருவாக்க முயற்சிக்கும்.
.PHONY: all 

# Ex 1: .o கோப்புகள் .c கோப்புகளைப் பொறுத்தது. நாம் உண்மையில் .o கோப்பை உருவாக்கவில்லை என்றாலும்.
$(filter %.o,$(obj_files)): %.o: %.c
	echo "target: $@ prereq: $<"

# Ex 2: .result கோப்புகள் .raw கோப்புகளைப் பொறுத்தது. நாம் உண்மையில் .result கோப்பை உருவாக்கவில்லை என்றாலும்
$(filter %.result,$(obj_files)): %.result: %.raw
	echo "target: $@ prereq: $<" 

%.c %.raw:
	touch $@

clean:
	rm -f $(src_files)
#+end_src

** வடிவ விதிகள்(Pattern Rules)

வடிவ விதிகள் பெரும்பாலும் பயன்படுத்தப்படுகின்றன ஆனால் மிகவும் குழப்பமானவை. நீங்கள் அவற்றை இரண்டு வழிகளில் பார்க்கலாம்:

- உங்கள் சொந்த மறைமுக விதிகளை வரையறுக்க ஒரு வழி
- நிலையான வடிவ விதிகளின்(Static Pattern Rules) எளிமையான வடிவம்

முதலில் ஒரு உதாரணத்துடன் ஆரம்பிக்கலாம்
#+begin_src makefile
# ஒவ்வொரு .c கோப்பையும் ஒரு .o கோப்பாக நிரல்மொழிமாற்றும் மாதிரி விதியை வரையறுக்கவும்
%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
#+end_src

வடிவ விதிகளில் இலக்கில் '%' உள்ளது. இந்த '%' எந்த காலியாக இல்லாத சரமுடன்(non empty string) பொருந்துகிறது, மற்ற எழுத்துக்கள் தங்களைப் பொருத்துகின்றன. ஒரு முறை விதியின் முன்நிபந்தனையில் '%' என்பது இலக்கில் உள்ள '%' உடன் பொருந்திய அதே தண்டைக்(stem) குறிக்கிறது.

இதோ மற்றொரு உதாரணம்:
#+begin_src makefile
# முன்நிபந்தனைகளில் எந்த வடிவமும் இல்லாத மாதிரி விதியை வரையறுக்கவும்.
# இது தேவைப்படும் போது வெற்று(empty) .c கோப்புகளை உருவாக்குகிறது.
%.c:
	touch $@
#+end_src

** இரட்டை முக்கால் புள்ளி விதிகள்(Double Colon rules)
இரட்டை முக்கால் புள்ளி விதிகள் அரிதாகவே பயன்படுத்தப்படுகின்றன, ஆனால் ஒரே இலக்குக்கு பல விதிகளை வரையறுக்க அனுமதிக்கின்றன. இவை ஒற்றை முக்கால் புள்ளி ஆக இருந்தால், ஒரு எச்சரிக்கை அச்சிடப்பட்டு, இரண்டாவது கட்டளைகள் மட்டுமே இயங்கும்.
#+begin_src makefile
all: blah

blah::
	echo "hello"

blah::
	echo "hello again"
#+end_src
* கட்டளைகள் மற்றும் செயல்படுத்தல் (Commands and Execution)
** கட்டளை எதிரொலி / அமைதிப்படுத்துதல் (Command Echoing/Silencing)
ஒரு கட்டளை அச்சிடப்படுவதை நிறுத்துவதற்கு, கட்டளைக்கு முன் @ ஐச் சேர்க்கவும்
ஒவ்வொரு வரிக்கும் முன்பு @ ஐச் சேர்க்க, நீங்கள் -s உடன் make ஐ இயக்கலாம்
#+begin_src makefile
all: 
	@echo "This make line will not be printed"
	echo "But this will"	 
#+end_src
** கட்டளை செயல்படுத்தல் (Command Execution)
ஒவ்வொரு கட்டளையும் ஒரு புதிய கூடுகலில்(shell) இயக்கப்படுகிறது (அல்லது குறைந்த பட்சம் விளைவு இப்படி இருக்கும்)
#+begin_src makefile
all: 
	cd ..
	# மேலே உள்ள cd இந்த வரியை பாதிக்காது, ஏனெனில் ஒவ்வொரு கட்டளையும் ஒரு புதிய ஷெல்லில் திறம்பட இயங்கும்
	echo `pwd`

	# இந்த cd கட்டளை அடுத்ததை பாதிக்கிறது, ஏனெனில் அவை ஒரே வரியில் உள்ளன
	cd ..;echo `pwd`

	# மேலே உள்ளது
	cd ..; \
	echo `pwd`	  
#+end_src

** இயல்புநிலை கூடு (Default Shell)
இயல்புநிலை கூடு என்பது /bin/sh ஆகும். மாறி SHELL மாற்றுவதன் மூலம் இதை மாற்றலாம்:
#+begin_src makefile
SHELL=/bin/bash

cool:
	echo "Hello from bash"
#+end_src

** இரட்டை டாலர் அடையாளம் (Double Dollar Sign)
ஒரு சரம் டாலர் அடையாளத்தைக் கொண்டிருக்க வேண்டுமெனில், நீங்கள் $$ ஐப் பயன்படுத்தலாம். பாஷ்(bash) அல்லது ஷில்(sh) கூடு மாறியைப் (shell variable) பயன்படுத்துவது இதுதான்.

இந்த அடுத்த எடுத்துக்காட்டில் மேக் கோப்பு மாறிகள்(Makefile variable) மற்றும் கூடு மாறிகள்(Shell variable) இடையே உள்ள வேறுபாடுகளைக் கவனியுங்கள்.

#+begin_src makefile
make_var = I am a make variable
all:
	# கூடுயில் "sh_var='I am a shell variable'; echo $sh_var" இயங்குவது போலவே
	sh_var='I am a shell variable'; echo $$sh_var

	# கூடுயில் "echo I am a make variable" இயங்குவது போலவே
	echo $(make_var)
#+end_src

** பிழை கையாளுதல் -k, -i, மற்றும் -
- இயங்கும் போது -k ஐச் சேர், பிழைகள் ஏற்பட்டாலும் தொடர்ந்து இயங்கச் செய்யுங்கள். மேக்கின் அனைத்து பிழைகளையும் ஒரே நேரத்தில் பார்க்க விரும்பினால் உதவியாக இருக்கும்.
- பிழையை ஒடுக்க(suppress) ஒரு கட்டளைக்கு முன் ஒரு - ஐச் சேர்க்கவும்
- ஒவ்வொரு கட்டளைக்கும் பிழையை ஒடுக்குவதற்கு -i ஐ மேக் உடன் சேர்க்கவும்.

#+begin_src makefile
one:
	# இந்தப் பிழை அச்சிடப்படும், ஆனால் புறக்கணிக்கப்பட்டு, மேலும் மேக் தொடர்ந்து இயங்கும்
	-false
	touch one
#+end_src

** மேக் குறுக்கீடுதல் அல்லது அழித்தல் (Interrupting or killing make)

குறிப்பு மட்டும்: நீங்கள் ctrl+c ஐ மேக் இயங்குபோது கூடுத்தால், அது உருவாக்கிய புதிய இலக்குகளை நீக்கிவிடும்.


** மேக்கில் மீள்சுருள் பயன்பாடு (Recursive use of make)

மேக் கோப்பை மீண்டும் மீண்டும் அழைக்க, மேக்கிற்குப் பதிலாக பிரத்யேக $(MAKE) ஐப் பயன்படுத்தவும், ஏனெனில் அது உங்களுக்கான மேக் கொடிகளை சேர்த்து அனுப்பும் மற்றும் அவற்றால் பாதிக்கப்படாது.

#+begin_src makefile
new_contents = "hello:\n\ttouch inside_file"
all:
	mkdir -p subdir
	printf $(new_contents) | sed -e 's/^ //' > subdir/makefile
	cd subdir && $(MAKE)

clean:
	rm -rf subdir	  
#+end_src

** மேக்கில் ஏற்றுமதி, சூழல்கள் மற்றும் மீள்சுருள் (Export, Environments and Recursive make)

மேக் தொடங்கும் போது, எந்த சூழல் மாறிகள்(Environment variable) நிறுவப்பட்டு உள்ளதோ அது மேக் மாறிகளாக தானாகவே உருவாக்குகிறது.

#+begin_src makefile
# இதை "export shell_env_var='I am an environment variable'; make" உடன் இயக்கவும்
all:
	# கூடு மாறியை(shell variable) அச்சிடவும்
	echo $$shell_env_var

	# மேக் மாறியை அச்சிடவும்
	echo $(shell_env_var)	  
#+end_src

ஏற்றுமதி நெறியுறுத்தம்(export directive) ஒரு மாறியை எடுத்து அனைத்து தயாரிப்பு முறைகளிலும்(recipes) உள்ள அனைத்து கூடு கட்டளைகளுக்கும்(shell variable) சூழலை(environment) அமைக்கிறது:

#+begin_src makefile
shell_env_var=Shell env var, created inside of Make
export shell_env_var
all:
	echo $(shell_env_var)
	echo $$shell_env_var
#+end_src

எனவே, நீங்கள் மேக் இன் உள்ளே மேக் கட்டளையை இயக்கும் போது, ​​நீங்கள் ஏற்றுமதி நெறியுறுத்தல் பயன்படுத்தி துணை-மேக்(sub-make) கட்டளைகளை அணுகலாம். இந்த எடுத்துக்காட்டில், துணை கோப்புறை(sub directory) உள்ள மேக் கோப்பை பயன்படுத்தும் வகையில் cooly ஏற்றுமதி செய்யப்படுகிறது

#+begin_src makefile
new_contents = "hello:\n\techo \$$(cooly)"

all:
	mkdir -p subdir
	printf $(new_contents) | sed -e 's/^ //' > subdir/makefile
	@echo "---MAKEFILE CONTENTS---"
	@cd subdir && cat makefile
	@echo "---END MAKEFILE CONTENTS---"
	cd subdir && $(MAKE)

# மாறிகள் மற்றும் ஏற்றுமதிகள் என்பதை நினைவில் கொள்க. அவை பொதுவாக(globally) அமைக்கப்பட்டுள்ளன/பாதிக்கப்படுகின்றன.
cooly = "The subdirectory can see me!"
export cooly
# இது மேலே உள்ள வரியை ரத்து செய்யும்: cooly ஏற்றுமதியை நீக்கவும்

clean:
	rm -rf subdir
#+end_src

கூடுகாலிலும் இயங்குவதற்கு மாறிகளை ஏற்றுமதி செய்ய வேண்டும்.

#+begin_src makefile
one=this will only work locally
export two=we can run subcommands with this

all: 
	@echo $(one)
	@echo $$one
	@echo $(two)
	@echo $$two
#+end_src

.EXPORT_ALL_VARIABLES உங்களுக்கான அனைத்து மாறிகளையும் ஏற்றுமதி செய்கிறது.

#+begin_src makefile
.EXPORT_ALL_VARIABLES:
new_contents = "hello:\n\techo \$$(cooly)"

cooly = "The subdirectory can see me!"
# இது மேலே உள்ள வரியை ரத்து செய்யும்: cooly ஏற்றுமதியை நீக்கவும்

all:
	mkdir -p subdir
	printf $(new_contents) | sed -e 's/^ //' > subdir/makefile
	@echo "---MAKEFILE CONTENTS---"
	@cd subdir && cat makefile
	@echo "---END MAKEFILE CONTENTS---"
	cd subdir && $(MAKE)

clean:
	rm -rf subdir
#+end_src

** மேக்கின் தருமதிப்புகள்
மேக் இருந்து இயக்கக்கூடிய விருப்பங்களின் நல்ல பட்டியல் உள்ளது. --dry-run, --touch, --old-file ஐ பார்க்கவும்.

நீங்கள் மேக் மூலம் பல இலக்குகளை இயக்கலாம் i.e make clean run test அது clean முதலில் பின் run பின் test யை செயல்படுத்தும்

* மாறிகள் பகுதி 2
** சுவைகள் மற்றும் மாற்றம்(Flavors and Modifications)
மாறிகளில் இரண்டு சுவைகள் உள்ளன:
- மீள்சுருள்(recursive) (பயன்பாடு =) - கட்டளை பயன்படுத்தப்படும் போது மட்டுமே மாறிகளை தேடுகிறது, அது வரையறுக்கப்படும்(defined) போது அல்ல.
- வெறுமனே விரிவாக்கப்பட்டது (பயன்படுத்தவும் :=) - சாதாரண கட்டாய நிரலாக்கத்தைப்(Imperative programmming) போல -- இதுவரை வரையறுக்கப்பட்டவை(defined) மட்டுமே விரிவாக்கப்படும்

#+begin_src makefile
# மீள்சுருள் மாறி. இது கீழே "later" அச்சிடப்படும்
one = one ${later_variable}
# வெறுமனே விரிவாக்கப்பட்ட மாறி. இது கீழே "later" என்று அச்சிடாது
two := two ${later_variable}

later_variable = later

all: 
	echo $(one)
	echo $(two)
#+end_src

எளிமையாக விரிவாக்கப்பட்டது (:= பயன்படுத்தி) ஒரு மாறியில் மதிப்பை இணைக்க(append) அனுமதிக்கிறது. மீள்சுருள் வரையறைகள்(Recursive definition) ஒரு எல்லையற்ற சுழற்சிப் பிழையைக்(Infinite loop error) கொடுக்கும்.
#+begin_src makefile
one = hello
# வெறுமனே விரிவாக்கப்பட்ட மாறி (:=) என வரையறுக்கப்படுகிறது, இதனால் இணைப்பதைக்(appending) கையாள முடியும்
one := ${one} there

all: 
	echo $(one)
#+end_src
?= இது மாறிகள் இன்னும் அமைக்கப்படவில்லை(not set) என்றால் மட்டுமே அமைக்கிறது
#+begin_src makefile
one = hello
one ?= will not be set
two ?= will be set

all: 
	echo $(one)
	echo $(two)
#+end_src
ஒரு வரியின் முடிவில் உள்ள இடைவெளிகள்(Spaces) அகற்றப்படவில்லை, ஆனால் தொடக்கத்தில் உள்ளவை அகற்றப்படும். ஒற்றை இடைவெளியுடன்(Single space) மாறியை உருவாக்க,$(nullstring) பயன்படுத்தவும்.
#+begin_src makefile
with_spaces = hello # with_spaces "hello"க்குப் பிறகு பல இடைவெளிகளைக் கொண்டுள்ளது
after = $(with_spaces)there

nullstring =
space = $(nullstring) # ஒற்றை இடைவெளியுடன் ஒரு மாறியை உருவாக்கவும்.

all: 
	echo "$(after)"
	echo start"$(space)"end
#+end_src
ஒரு வரையறுக்கப்படாத மாறி(Undefined variable) உண்மையில் ஒரு வெற்று சரம்(empty string)!
#+begin_src makefile
all: 
# வரையறுக்கப்படாத மாறிகள் வெறும் வெற்று சரங்கள்!
	echo $(nowhere)
#+end_src
இணைக்க += ஐப் பயன்படுத்தவும்
#+begin_src makefile
foo := start
foo += more

all: 
	echo $(foo)
#+end_src
சரம் மாற்று(String substitution) என்பது மாறிகளை மாற்றுவதற்கான மிகவும் பொதுவான மற்றும் பயனுள்ள வழியாகும்.மேலும் உரை செயல்பாடுகள்(Text function) மற்றும் கோப்பு பெயர் செயல்பாடுகளையும்(Textfilename function) பார்க்கவும்.
** கட்டளை வரி வாதங்கள் மற்றும் மேலாணை(Command line arguments and Override)
மேலாணையைப் பயன்படுத்தி கட்டளை வரியிலிருந்து வரும் மாறிகளை நீங்கள் மேலாணை(override) செய்யலாம். இங்கே நாம் make option_one=hi உடன் make ஐ இயக்கினோம்
#+begin_src makefile
# மேலாணைகள் கட்டளை வரி வாதங்கள்
override option_one = did_override
# கட்டளை வரி வாதங்களுக்கு மேலாணை செய்யாது
option_two = not_override
all: 
	echo $(option_one)
	echo $(option_two)
#+end_src

** கட்டளைகளின் பட்டியல் மற்றும் வரையறு (List of commands and define)

வரையறு நெறியுறுத்தம்(define directive) ஒரு செயல்பாடு அல்ல, அது அப்படித் தோன்றினாலும். இது மிகவும் அரிதாகவே பயன்படுத்தப்படுவதை நான் பார்த்திருக்கிறேன், நான் விவரங்களுக்குச் செல்லமாட்டேன், ஆனால் இது முக்கியமாக பதிவு செய்யப்பட்ட தயாரிப்பு குறிப்புகளை வரையறுக்கப் பயன்படுகிறது மற்றும் eval செயல்பாட்டுடன் நன்றாக இணைகிறது.

define/endef என்பது கட்டளைகளின் பட்டியலில் அமைக்கப்பட்ட ஒரு மாறியை உருவாக்குகிறது. கட்டளைகளுக்கு இடையில் ஒரு அரைப்புள்ளி(Semicolon) இருப்பதை விட இது சற்று வித்தியாசமானது என்பதை இங்கே கவனிக்கவும், ஏனெனில் ஒவ்வொன்றும் தனித்தனி கூடுகலில்(Shell) இயங்கும்.

#+begin_src makefile
one = export blah="I was set!"; echo $$blah

define two
export blah="I was set!"
echo $$blah
endef

all: 
	@echo "This prints 'I was set'"
	@$(one)
	@echo "This does not print 'I was set' because each command runs in a separate shell"
	@$(two)
#+end_src

** இலக்கு-குறிப்பிட்ட மாறிகள் (Target-specific variables)

குறிப்பிட்ட இலக்குகளுக்கு மாறிகளை அமைக்கலாம்

#+begin_src makefile
all: one = cool

all: 
	echo one is defined: $(one)

other:
	echo one is nothing: $(one)
#+end_src

** வடிவ-குறிப்பிட்ட மாறிகள் (Pattern-specific variables)

குறிப்பிட்ட இலக்கு வடிவங்களுக்கு நீங்கள் மாறிகளை அமைக்கலாம்

#+begin_src makefile
%.c: one = cool

blah.c: 
	echo one is defined: $(one)

other:
	echo one is nothing: $(one)
#+end_src

* மேக் கோப்புபின் நிபந்தனை பகுதி (Conditional part of Makefiles)
** நிபந்தனை ஆனால்/இல்லை (Conditional if/else)
#+begin_src makefile
foo = ok

all:
ifeq ($(foo), ok)
	echo "foo equals ok"
else
	echo "nope"
endif
#+end_src
** ஒரு மாறி காலியாக உள்ளதா என சரிபார்க்க (Check if a variable is empty)
#+begin_src makefile
nullstring =
foo = $(nullstring) # வரியின் முடிவு; இங்கே ஒரு இடைவெளி உள்ளது

all:
ifeq ($(strip $(foo)),)
	echo "foo is empty after being stripped"
endif
ifeq ($(nullstring),)
	echo "nullstring doesn't even have spaces"
endif
#+end_src
** ஒரு மாறி வரையறுக்கப்பட்டுள்ளதா என சரிபார்க்க (Check if a variable is defined)
ifdef மாறி குறிப்புகளை விரிவாக்காது; ஏதாவது வரையறுக்கப்பட்டுள்ளதா என்று தான் பார்க்கிறது
#+begin_src makefile
bar =
foo = $(bar)

all:
ifdef foo
	echo "foo is defined"
endif
ifndef bar
	echo "but bar is not"
endif
#+end_src
** $(MAKEFLAGS)
Findstring மற்றும் MAKEFLAGS மூலம் கொடிகளை(flag) உருவாக்குவது எப்படி என்பதை இந்த எடுத்துக்காட்டு காட்டுகிறது. எதிரொலி அறிக்கையை(echo statement) அச்சிடுவதைப் பார்க்க, இந்த உதாரணத்தை make -i உடன் இயக்கவும்.
#+begin_src makefile
all:
# "-i" கொடியைத் தேடுங்கள். MAKEFLAGS என்பது ஒற்றை எழுத்துகளின் பட்டியல் மட்டுமே, ஒரு கொடிக்கு ஒன்று. எனவே இந்த வழக்கில் "i" ஐத் தேடுங்கள்.
ifneq (,$(findstring i, $(MAKEFLAGS)))
	echo "i was passed to MAKEFLAGS"
endif
#+end_src
* செயல்பாடுகள் (Functions)
** முதல் செயல்பாடுகள் (First functions)
செயல்பாடுகள் முக்கியமாக உரை செயலாக்கத்திற்கு(text processing) மட்டுமே. $(fn, arguments) அல்லது ${fn, arguments} உடன் செயல்பாடுகளை அழைக்கவும். மேக் ஒரு நல்ல அளவு உள்ளமைந்த செயல்பாடுகளைக்(Builtin Functions) கொண்டுள்ளது.
#+begin_src makefile
bar := ${subst not,"totally", "I am not superman"}
all: 
	@echo $(bar)
#+end_src
இடைவெளிகள்(space) அல்லது காற்புள்ளிகளை(commas) மாற்ற விரும்பினால், மாறிகளைப் பயன்படுத்தவும்
#+begin_src makefile
comma := ,
empty:=
space := $(empty) $(empty)
foo := a b c
bar := $(subst $(space),$(comma),$(foo))

all: 
	@echo $(bar)
#+end_src
முதல் வாதங்களுக்குப்(argument) பிறகு இடைவெளிகளைச் சேர்க்க வேண்டாம். அது சரத்தின் ஒரு பகுதியாகவே பார்க்கப்படும்.
#+begin_src makefile
comma := ,
empty:=
space := $(empty) $(empty)
foo := a b c
bar := $(subst $(space), $(comma) , $(foo)) # கவனியுங்கள்!

all: 
# வெளியீடு ", a , b , c" ஆகும். அறிமுகப்படுத்தப்பட்ட இடைவெளிகளைக் கவனியுங்கள்
	@echo $(bar)
#+end_src
** சரம் பதிலீட்டு (String substitution)

$(patsubst pattern,replacement,text) பின்வருவனவற்றைச் செய்கிறது:

"வடிவத்துடன்(Pattern) பொருந்தக்கூடிய இடைவெளிகளால்-பிரிக்கப்பட்ட சொற்களைக் கண்டறிந்து அவற்றை மாற்றியமைக்கிறது. இங்கே வடிவம்(pattern) ஒரு '%' ஐக் கொண்டிருக்கலாம், இது ஒரு குழுக்குறியாக(Wild card) செயல்படும், ஒரு வார்த்தையில் உள்ள எந்த எழுத்துகளின் எண்ணிக்கையையும் பொருத்துகிறது.மாற்றீட்டில் ‘%’ இருந்தால், ‘%’ ஆனது, வடிவில் உள்ள ‘%’ உடன் பொருந்திய உரையால்(text) மாற்றப்படும். வடிவத்தில் உள்ள முதல் '%' மட்டுமே மாற்றீட்டில் இந்த வழியில் நடத்தப்படுகிறது; அடுத்து வரும் '%' மாறாமல் இருக்கும்."  (குனு டாக்ஸ்)

இந்த $(text:pattern=replacement) சுருக்கெழுத்து பதிலீட்டு குறிப்புபை(substitution reference) குறிக்கிறது.

பின்னொட்டுகளை(suffixes) மட்டும் மாற்றும் மற்றொரு சுருக்கெழுத்து உள்ளது: $(text:suffix=replacement). இங்கு % குழுக்குறி(Wildcard) பயன்படுத்தப்படவில்லை.

குறிப்பு: இந்த சுருக்கெழுத்துக்கு கூடுதல் இடைவெளிகளைச் சேர்க்க வேண்டாம். இது ஒரு தேடல்(search) அல்லது மாற்று(replacement) வார்த்தையாக பார்க்கப்படும்.

#+begin_src makefile
foo := a.o b.o l.a c.o
one := $(patsubst %.o,%.c,$(foo))
# இது மேற்கூறியவற்றுக்கான சுருக்கெழுத்து
two := $(foo:%.o=%.c)
# இது பின்னொட்டு(suffix)-மட்டும் சுருக்கெழுத்து, மேலும் மேற்கூறியதற்குச் சமமானதாகும்.
three := $(foo:.o=.c)

all:
	echo $(one)
	echo $(two)
	echo $(three)
#+end_src

** ஒவ்வொரு செயல்பாடு(The foreach function)
ஒவ்வொரு(foreach) செயல்பாடு இது போல் இருக்கும்: $(foreach var,list,text). இது ஒரு வார்த்தைகளின் பட்டியலை (இடைவெளிகளால் பிரிக்கப்பட்டது) மற்றொன்றுக்கு மாற்றுகிறது. பட்டியலில் உள்ள ஒவ்வொரு வார்த்தைக்கும் var அமைக்கப்பட்டுள்ளது, மேலும் ஒவ்வொரு வார்த்தைக்கும் உரை விரிவாக்கப்படும்(expands). 

இது ஒவ்வொரு வார்த்தையின் பின்னும் ஒரு ஆச்சரியகுறியைச் சேர்க்கிறது:
#+begin_src makefile
foo := who are you
# foo இல் உள்ள ஒவ்வொரு "வார்த்தைக்கும்", அதே வார்த்தையை பின்னர் ஆச்சரியகுறியுடன் வெளியிடவும்
bar := $(foreach wrd,$(foo),$(wrd)!)

all:
	# வெளியீடு "who! are! you!" ஆகும்
	@echo $(bar)
#+end_src

** எனில் செயல்பாடு (The if function)
எனில் செயல்பாடு முதல் வாதம் காலியாக உள்ளதா என சரிபார்க்கும். அப்படியானால், இரண்டாவது வாதத்தை இயக்கவும், இல்லையெனில் மூன்றாவது இயங்கும்
#+begin_src makefile
foo := $(if this-is-not-empty,then!,else!)
empty :=
bar := $(if $(empty),then!,else!)

all:
	@echo $(foo)
	@echo $(bar)
#+end_src

** அழைப்பு செயல்பாடு (The call function)
அடிப்படை செயல்பாடுகளை உருவாக்கும் ஆதரவை Make ஆதரிக்கிறது. ஒரு மாறியை உருவாக்குவதன் மூலம் செயல்பாட்டை "வரையறு(define)" செய்கிறீர்கள், ஆனால் $(0), $(1) போன்ற அளவுருக்களைப்(parameters) பயன்படுத்தவும். நீங்கள் செயல்பாட்டை சிறப்பு அழைப்பு உள்ளமைந்த செயல்பாடு மூலம் அழைக்கிறீர்கள். தொடரியல்(syntax) $(call variable,param,param) ஆகும். $(0) என்பது மாறி, அதே சமயம் $(1), $(2) போன்றவை அளவுருக்கள்(parameters).
#+begin_src makefile
sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)

all:
        # வெளியீடுகள் "Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:"
	@echo $(call sweet_new_fn, go, tigers)
#+end_src

** கூடு செயல்பாடு (The shell function)
கூடு - இது கூடுடை அழைக்கிறது, ஆனால் இது புதிய வரிகளை(new lines) இடைவெளிகளுடன் மாற்றுகிறது!
#+begin_src makefile
all: 
	@echo $(shell ls -la) # மிகவும் அசிங்கம் ஏனெனில் புதிய வரிகள் போய்விட்டன!
#+end_src

** வடிகட்டி செயல்பாடு (The filter function)
ஒரு குறிப்பிட்ட வடிவத்துடன் பொருந்தக்கூடிய பட்டியலிலிருந்து சில கூறுகளைத்(elements) தேர்ந்தெடுக்க வடிகட்டி செயல்பாடு பயன்படுத்தப்படுகிறது. எடுத்துக்காட்டாக, இது obj_files இல் .o உடன் முடிவடையும் அனைத்து கூறுகளையும்(elements) தேர்ந்தெடுக்கும்.

#+begin_src makefile
obj_files = foo.result bar.o lose.o
filtered_files = $(filter %.o,$(obj_files))

all:
	@echo $(filtered_files)
#+end_src

வடிகட்டி மிகவும் சிக்கலான வழிகளிலும் பயன்படுத்தப்படலாம்:
- பல வடிவங்களை வடிகட்டுதல்(Filtering multiple patterns): ஒரே நேரத்தில் பல வடிவங்களை வடிகட்டலாம். எடுத்துக்காட்டாக, $(filter %.c %.h, $(files)) கோப்புகள் பட்டியலில்(list) இருந்து அனைத்து .c மற்றும் .h கோப்புகளையும் தேர்ந்தெடுக்கும்.
- மறுப்பு(Negation): வடிவத்துடன் பொருந்தாத அனைத்து கூறுகளையும் நீங்கள் தேர்ந்தெடுக்க விரும்பினால், filter-out பயன்படுத்தலாம். எடுத்துக்காட்டாக, $(filter-out %.h, $(files)) .h கோப்புகள் அல்லாத எல்லா கோப்புகளையும் தேர்ந்தெடுக்கும்.
- உட்பொதிவு வடிகட்டி(Nested filter): பல வடிகட்டிகளைப் பயன்படுத்த, நீங்கள் உட்பொதிவு(nested) வடிகட்டி செயல்பாடுகளை செய்யலாம். எடுத்துக்காட்டாக,  $(filter %.o, $(filter-out test%, $(objects))) .o உடன் முடிவடையும் ஆனால் test இல் தொடங்காத அனைத்து .o பொருள்(object) கோப்புகளையும் தேர்ந்தெடுக்கும்.

* மற்ற அம்சங்கள் (Other Features)
** மேக் கோப்புயை உள்ளடக்கு (Include Makefiles)
உள்ளடக்கு நெறியுறுத்தம்(include directive) ஒன்று அல்லது அதற்கு மேற்பட்ட மற்ற மேக் கோப்புகளைப் படிக்கச் சொல்லும் கட்டளையை உள்ளடக்கியது. அது மேக் கோப்புயில் ஒரு வரி இது போல் இருக்கும்:
#+begin_src makefile
include filenames...
#+end_src
இது மிகவும் பயனுள்ளதாக இருக்கும், -M போன்ற நிரல்மொழிமாற்றி கொடிகளைப் பயன்படுத்தும்போது மூலத்தின்(source) அடிப்படையில் Makefiles ஐ உருவாக்கும் போது. எடுத்துக்காட்டாக, சில c கோப்புகளில் தலைப்பு(header) இருந்தால், அந்த தலைப்பு gcc ஆல் எழுதப்பட்ட மேக் கோப்புயில் சேர்க்கப்படும். மேக் கோப்பு சமையல் புத்தகத்தில்(cookbook) இதைப் பற்றி அதிகம் பேசுகிறேன்

** vpath நெறியுறுத்தம் (The vpath Directive)
சில முன்நிபந்தனைகள் எங்கு உள்ளன என்பதைக் குறிப்பிட vpath ஐப் பயன்படுத்தவும். படிவம்(format) இப்படி இருக்கும் ~vpath <pattern> <directories, space/colon separated>~ <pattern> பூஜ்ஜியம் அல்லது அதற்கு மேற்பட்ட எழுத்துகளுடன் பொருந்தக்கூடிய % ஐக் கொண்டிருக்கலாம். VPATH என்ற மாறி மூலம் பொது(globally) அளவில் இதைச் செய்யலாம்.

#+begin_src makefile
vpath %.h ../headers ../other-directory

# குறிப்பு: vpath தற்போதைய கோப்பகத்தில்(folder) blah.h இல்லாவிட்டாலும் blah.h ஐக் கண்டறிய அனுமதிக்கிறது
some_binary: ../headers blah.h
	touch some_binary

../headers:
	mkdir ../headers

# நாம் இலக்கை ../headers/blah.h என்பதற்குப் பதிலாக blah.h என்று அழைக்கிறோம், ஏனெனில் some_binary தேடும் முன்நிபந்தனை இருப்பதால்.
# பொதுவாக, blah.h ஏற்கனவே இருக்கும், உங்களுக்கு இது தேவைப்படாது.
blah.h:
	touch ../headers/blah.h

clean:
	rm -rf ../headers
	rm -f some_binary
#+end_src

** பல வரி (Multiline)
கட்டளைகள் மிக நீளமாக இருக்கும்போது பல வரிகளைப் பயன்படுத்தும் திறனை பின்சாய்கோடு ("\") எழுத்து நமக்கு வழங்குகிறது
#+begin_src makefile
some_file: 
	echo This line is too long, so \
	  it is broken up into multiple lines
#+end_src

** .phony


Adding .PHONY to a target will prevent Make from confusing the phony target with a file name. In this example, if the file clean is created, make clean will still be run. Technically, I should have used it in every example with all or clean, but I wanted to keep the examples clean. Additionally, "phony" targets typically have names that are rarely file names, and in practice many people skip this.
